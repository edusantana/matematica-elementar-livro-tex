[[cap3]]
== Equações de Recorrência e Provas por Indução Matemática

Deus nos deu duas formas básicas de raciocínio: o indutivo e o dedutivo. Às vezes são bem usados, muitas vezes não.

* O *raciocínio indutivo* parte de experiências e observações de fatos individuais e tenta chegar a conclusões, a regras que expliquem os fatos e generalizem as observações (Por exemplo: ``estou atravessando esta pequena cidade de madrugada, só vi 3 pessoas nas ruas, e todas elas estavam bêbadas. Daí, posso induzir que todos os habitantes dela são bêbados.'' Onde está o erro deste raciocínio?). 
*  O *raciocínio dedutivo*, baseando-se na lógica, parte de axiomas e de teoremas já demonstrados e, usando regras de inferência da lógica, chega a conclusões (Por exemplo: ``sem exceção, todos os homens de tal família são e serão desonestos, todos concordam, não é?; esse menino acabou de nascer nessa família; logo, será desonesto'' Onde está a falácia deste raciocínio?).

Feitos de forma intuitiva e informal (portanto com riscos de imprecisão e ambiguidade) ambos tais tipos de raciocínio podem levar a erros, tanto na vida informal como na Matemática e demais ciências exatas.

Nosso objetivo neste capítulo é que, ao final, você, usando os rigores da Matemática e da Lógica, saiba perfeitamente como estudar problemas e os modelar usando o que chamaremos de equações de recorrência, depois usar um são e preciso raciocínio indutivo para produzir provas de indução usando tamanhos formalismo e rigor que lhes garantam absolutas precisão e corretude. No <<cap4>> faremos o mesmo quanto o raciocínio dedutivo.

.Lembre:
[TIP]
====
Estamos torcendo por você. O fórum de alunos, os tutores, e eu (o professor) queremos e vamos ajudá-lo (nessa ordem), mas você tem que ser determinado e disciplinado, *cada semana dedicando 4 a 8 horas para estudar este livro*.
====

.Conteúdo deste capítulo
____________________
* Equações de Recorrência. Determinação Delas. Fórmulas Fechadas (Conjecturas)
* Provas pelo Princípio da Indução Matemática Simples (ou Fraca)
* Provas pelo Princípio de Indução Matemática Completa (ou Forte)
____________________

[NOTE]
====
Se você quiser ver o assunto mais explicado e profundamente, não precisará de mais que os livros textos da ementa da disciplina. Mas, se ademais ou ao invés deles, quiser algo gratuito ou da internet, talvez possa começar por _Indução Matemática, Abramo Hefez_,  http://server22.obmep.org.br:8080/media/servicos/recursos/296654.o; ou Indução e Indução Matemática, palestra de José Morgado http://nautilus.fis.uc.pt/bspm/revistas/17/023-034.150.pdf. Agradeço ao aluno Túlio Albuquerque Pascoal por ter ajudado a revisar esta unidade.
====

[[sec-3-1]]
=== Equações de Recorrência. Determinação Delas. Fórmulas Fechadas (Conjecturas)

Uma *Relação de Recorrência* ou *Equação de Recorrência* é aquela que, em parte de sua definição, diz como resolver diretamente a menor e mais simples possível instância do problema, e nisso não faz referência a nenhuma outra instância do problema; e, no restante da sua definição, diz como resolver instâncias maiores e mais complexas do problema, nisso usando, fazendo referência a uma ou mais de suas instâncias menores. Em outras palavras, uma recorrência é uma expressão que dá o valor de uma função em termos dos valores ``anteriores'' da mesma função. Uma função recursiva latexmath:[$f(n)$] é definida em termos de valores para latexmath:[$f(m)$], onde latexmath:[$m < n$].

.{zwsp}
====
a) No domínio dos naturais, você define fatorial de latexmath:[$n$] como 1, se latexmath:[$n$] for 0; e define como latexmath:[$n$] vezes fatorial de latexmath:[$n-1$], se latexmath:[$n$] for maior que 0:

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$n! = 1$] 			|caso latexmath:[$n = 0$]
|latexmath:[$n! = n(n-1)!$]		|caso latexmath:[$n > 0$]
|====

b) Você define a relação binária ``É_Ancestral_De'' assim:

[width="90%", cols="<", grid="none", frame="none"]
|====
|latexmath:[$x \mbox{ É_Ancestral_De } z \mbox{ SE } x \mbox{ É_Pai_Ou_Mãe_De } y \mbox{ E } y \mbox{ É_Ancestral_De } z$].
|latexmath:[$OU$]
|latexmath:[$x \mbox{ É_Ancestral_De } y \mbox{ SE } x \mbox{ É_Pai_Ou_Mãe_De } y$]
|====

c) No domínio dos naturais não nulos latexmath:[$\{1,2,3,\ldots\}$], você define a soma dos latexmath:[$n$] primeiros deles como sendo 1 se latexmath:[$n$] for 1, e como sendo latexmath:[$n$] mais a soma dos latexmath:[$n-1$] primeiros naturais, se latexmath:[$n$] for maior que 1:

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$S(n) = 1$] 			|caso latexmath:[$n = 1$]
|latexmath:[$S(n) = n + S(n-1)$]	|caso latexmath:[$n > 1$]
|====

d) (Prof. Becceneri, INPE): Um processo cria memória dinamicamente. Inicialmente, aloca 64 MB (chamemos isto de latexmath:[$M_0$]). A cada iteração exige mais 15% de memória. Então, as equações de recorrência para este problema são (complete): 

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$M_i = 64$] 			|para latexmath:[$i = 0$]
|latexmath:[$M_i = 1,15M_{i-1}$]	|para latexmath:[$i > 0$]
|====

e) latexmath:[$n$] está no domínio dos naturais não nulos, e você sabe que uma certa função f de latexmath:[$n$] vale 1 para latexmath:[$n=1$], e, nos demais casos, vale o valor anterior latexmath:[$(f(n-1))$] mais latexmath:[$3n$] mais latexmath:[$2$]. Escreva as equações de recorrência:

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$f(n) = 1$] 				|caso latexmath:[$n = 1$]
|latexmath:[$f(n) = f(n-1) + 3n + 2$]	|caso latexmath:[$n > 1$]
|====
====

Uma recorrência pode ser vista como um *algoritmo recursivo* que calcula uma função a partir de um ``valor inicial''. Talvez haja um fundo de verdade em quem diz que ``_saber programar é saber achar algoritmos recursivos, e vice-versa, e ambas essas coisas equivalem à proficiência em achar definições recursivas para funções._'' Achamos que, se isso não for totalmente verdade, tem um certo fundo de verdade, e isso é bom. Nesta unidade, primeiramente invistamos em achar definições recursivas, pois isto vai lhe ajudar muito a programar, no futuro. E, em segundo lugar, invistamos também em achar fórmulas fechadas para recursões e prová-las rigorosamente, por indução, pois isto vai ajudá-lo a descobrir como é fácil errarmos em pensar que uma recursão ou loop estão totalmente corretos, e vai nos ensinar a ser mais cuidadosos, e a identificar e corrigir esses erros, e a saber provar a corretude de programas (mesmo os iterativos). 

*Resolver* um sistema de equações recorrentes é encontrar uma *fórmula fechada* que lhe seja solução. Uma *fórmula fechada*, ou *solução explícita*, dá o valor da função recursiva diretamente em termos do seu argumento, sem referência a nenhum valor da função para uma instância menor do problema. Tipicamente, uma fórmula fechada é uma combinação de polinômios, de quocientes de polinômios, de logaritmos, de exponenciais, etc. Só não pode ter recorrência dentro dela, isto é, não pode se referir a instâncias menores do problema, mesmo que disfarçadas dentro de somatórios (latexmath:[$\sum$]) e produtórios (latexmath:[$\prod$]) e loops de programas.

.{zwsp}
====
Ache a fórmula fechada para os problemas c, d, e, do exemplo acima.

{zwsp} +
*Solução:*
c) Temos uma progressão aritmética de latexmath:[$n$] termos, primeiro termo (chamado de latexmath:[$S(1)$]) 1, e razão 1, e a fórmula da soma dos termos de uma P.A. nos dá

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$S(n) = \frac{n(1+n)}{2}$] |para latexmath:[$n \geq 1$]
|====

d) Temos uma progressão geométrica de latexmath:[$n+1$] termos, primeiro termo (chamado latexmath:[$M_0$]) 64, e quociente latexmath:[$1,15$], e a fórmula da soma dos termos de uma P.G. nos dá

[width="90%", cols="2<,1<", grid="none", frame="none"]
|====
|latexmath:[$64\frac{(1,15^{n+1} - 1)}{(1,15 - 1)} = 64 \frac{(1,15^{n+1} - 1)}{0,15} = 426,667(1,15^{n+1} - 1)$] |para latexmath:[$n \geq 0$]
|====

e) A resposta é latexmath:[$\frac{(3n^2)}{2} + \frac{7n}{2} - 4$]. Bem, é bastante fácil você verificar que a resposta está correta para qualquer latexmath:[$n$] relativamente pequeno latexmath:[$(1,2,3,4,5,6,\ldots)$]; dentro de poucas páginas você aprenderá a provar por indução que a fórmula é válida para todo natural não nulo; mas o mais difícil é como chegar ao começo de tudo, isto é, como ``adivinhar'' que a resposta, a fórmula fechada, é essa. Isso você só começará a ver, de leve, no exemplo 7, e, em casos mais difíceis (como o problema 2, muito difícil), talvez no mestrado, em cursos sobre Análise de Complexidade de Algoritmos (método de adivinhação inteligente, substituição, árvores de recorrência, etc.)
====



