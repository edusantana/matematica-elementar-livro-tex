[[cap3]]
== Equações de Recorrência e Provas por Indução Matemática

:cap: cap3
:online: {gitrepo}/blob/master/livro/capitulos/code/{cap}
:local: {code_dir}/{cap}
:img: {img_dir}/{cap}

.Objetivos do capítulo
____
Ao final deste capítulo você deverá ser capaz de (entre outras coisas):

* Modelar problemas do seu mundo real por meio de equações de
  recorrência, depois conjecturar uma fórmula fechada, finalmente
  prová-la por indução;
* Dado um conjunto de equações de recorrência para um problema, e dada
  uma conjectura (como uma fórmula fechada) para resolvê-las, provar a
  conjectura ser um teorema, precisa e formalmente usando  o Princípio
  de Indução Matemática Simples (ou Fraca), ou o Princípio de Indução
  Matemática Completa (ou Forte).

____


Deus nos deu duas formas básicas de raciocínio: o indutivo e o
dedutivo. Às vezes são bem usados, muitas vezes não.

* O *raciocínio indutivo* parte de experiências e observações de
fatos individuais e tenta chegar a conclusões, a regras que
expliquem os fatos e generalizem as observações (Por exemplo:
``estou atravessando esta pequena cidade de madrugada, só vi 3
pessoas nas ruas, e todas elas estavam bêbadas. Daí, posso induzir
que todos os habitantes dela são bêbados.'' Onde está o erro deste
raciocínio?).
*  O *raciocínio dedutivo*, baseando-se na lógica, parte de axiomas
e de teoremas já demonstrados e, usando regras de inferência da
lógica, chega a conclusões (Por exemplo: ``sem exceção, todos os
homens de tal família são e serão desonestos, todos concordam,
não é?; esse menino acabou de nascer nessa família; logo, será
desonesto'' Onde está a falácia deste raciocínio?).

Feitos de forma intuitiva e informal (portanto com riscos de
imprecisão e ambiguidade) ambos tais tipos de raciocínio podem
levar a erros, tanto na vida informal como na Matemática e demais
ciências exatas.

Nosso objetivo neste capítulo é que, ao final, você, usando os
rigores da Matemática e da Lógica, saiba perfeitamente como estudar
problemas e os modelar usando o que chamaremos de equações de
recorrência, depois usar um são e preciso raciocínio indutivo para
produzir provas de indução usando tamanhos formalismo e rigor que
lhes garantam absolutas precisão e corretude. No <<cap6>> faremos o
mesmo quanto o raciocínio dedutivo.

.Lembre:
[TIP]
====
Estamos torcendo por você. O fórum de alunos, os tutores, e eu (o
professor) queremos e vamos ajudá-lo (nessa ordem), mas você tem
que ser determinado e disciplinado, *cada semana dedicando 4 a 8
horas para estudar este livro*.
====

[NOTE]
====
Se você quiser ver o assunto mais explicado e profundamente, não
precisará de mais que os livros textos da ementa da disciplina. Mas,
se ademais ou ao invés deles, quiser algo gratuito ou da internet,
talvez possa começar por _Indução Matemática, Abramo Hefez_,
http://server22.obmep.org.br:8080/media/servicos/recursos/296654.o;
ou Indução e Indução Matemática, palestra de José Morgado
http://nautilus.fis.uc.pt/bspm/revistas/17/023-034.150.pdf. Agradeço
ao aluno Túlio Albuquerque Pascoal por ter ajudado a revisar este
capítulo.
====

[[sec-3-1]]
=== Equações de Recorrência. Determinação Delas. Fórmulas Fechadas (Conjecturas)

Uma *Relação de Recorrência* ou *Equação de Recorrência* é
aquela que, em parte de sua definição, diz como resolver
diretamente a menor e mais simples possível instância do problema,
e nisso não faz referência a nenhuma outra instância do problema;
e, no restante da sua definição, diz como resolver instâncias
maiores e mais complexas do problema, nisso usando, fazendo
referência a uma ou mais de suas instâncias menores. Em outras
palavras, uma recorrência é uma expressão que dá o valor de uma
função em termos dos valores ``anteriores'' da mesma função. Uma
função recursiva latexmath:[$f(n)$] é definida em termos de
valores para latexmath:[$f(m)$], onde latexmath:[$m < n$].

.{zwsp}
====
a) No domínio dos naturais, você define fatorial de latexmath:[$n$]
como 1, se latexmath:[$n$] for 0; e define como latexmath:[$n$] vezes
fatorial de latexmath:[$n-1$], se latexmath:[$n$] for maior que 0:

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$n! = 1$] 			|caso latexmath:[$n = 0$]
|latexmath:[$n! = n(n-1)!$]		|caso latexmath:[$n > 0$]
|====

b) Você define a relação binária ``É_Ancestral_De'' assim:

[width="90%", cols="^", grid="none", frame="none"]
|====
|latexmath:[$x$] É_Ancestral_De latexmath:[$z$] SE latexmath:[$x$]
É_Pai_Ou_Mãe_De latexmath:[$y$] E latexmath:[$y$] É_Ancestral_De
latexmath:[$z$]
|OU
|latexmath:[$x$] É_Ancestral_De latexmath:[$y$] SE latexmath:[$x$]
É_Pai_Ou_Mãe_De latexmath:[$y$]
|====

c) No domínio dos naturais não nulos
latexmath:[$\{1,2,3,\ldots\}$], você define a soma dos
latexmath:[$n$] primeiros deles como sendo 1 se latexmath:[$n$] for
1, e como sendo latexmath:[$n$] mais a soma dos latexmath:[$n-1$]
primeiros naturais, se latexmath:[$n$] for maior que 1:

[width="90%", cols="2<,4<", grid="none", frame="none"]
|====
|latexmath:[$S(n) = 1$] 			|caso latexmath:[$n = 1$]
|latexmath:[$S(n) = n + S(n-1)$]	|caso latexmath:[$n > 1$]
|====

d) (Prof. Becceneri, INPE): Um processo cria memória dinamicamente.
Inicialmente, aloca 64 MB (chamemos isto de latexmath:[$M_0$]). A
cada iteração exige mais 15% de memória. Então, as equações de
recorrência para este problema são (complete):

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$M_i = 64$] 			|para latexmath:[$i = 0$]
|latexmath:[$M_i = 1,15M_{i-1}$]	|para latexmath:[$i > 0$]
|====

e) latexmath:[$n$] está no domínio dos naturais não nulos, e você
sabe que uma certa função f de latexmath:[$n$] vale 1 para
latexmath:[$n=1$], e, nos demais casos, vale o valor anterior
latexmath:[$(f(n-1))$] mais latexmath:[$3n$] mais latexmath:[$2$].
Escreva as equações de recorrência:

[width="90%", cols="2<,4<", grid="none", frame="none"]
|====
|latexmath:[$f(n) = 1$] 				|caso
latexmath:[$n = 1$]
|latexmath:[$f(n) = f(n-1) + 3n + 2$]	|caso latexmath:[$n > 1$]
|====

====

Uma recorrência pode ser vista como um *algoritmo recursivo* que
calcula uma função a partir de um ``valor inicial''. Talvez haja um
fundo de verdade em quem diz que ``_saber programar é saber achar
algoritmos recursivos, e vice-versa, e ambas essas coisas equivalem
à proficiência em achar definições recursivas para funções._''
Achamos que, se isso não for totalmente verdade, tem um certo fundo
de verdade, e isso é bom. Neste capítulo, primeiramente invistamos em
achar definições recursivas, pois isto vai lhe ajudar muito a
programar, no futuro. E, em segundo lugar, invistamos também em
achar fórmulas fechadas para recursões e prová-las rigorosamente,
por indução, pois isto vai ajudá-lo a descobrir como é fácil
errarmos em pensar que uma recursão ou loop estão totalmente
corretos, e vai nos ensinar a ser mais cuidadosos, e a identificar e
corrigir esses erros, e a saber provar a corretude de programas
(mesmo os iterativos).

*Resolver* um sistema de equações recorrentes é encontrar uma
*fórmula fechada* que lhe seja solução. Uma *fórmula fechada*, ou
*solução explícita*, dá o valor da função recursiva diretamente
em termos do seu argumento, sem referência a nenhum valor da
função para uma instância menor do problema. Tipicamente, uma
fórmula fechada é uma combinação de polinômios, de quocientes de
polinômios, de logaritmos, de exponenciais, etc. Só não pode ter
recorrência dentro dela, isto é, não pode se referir a instâncias
menores do problema, mesmo que disfarçadas dentro de somatórios
(latexmath:[$\sum$]) e produtórios (latexmath:[$\prod$]) e loops de
programas.

.{zwsp}
====
Ache a fórmula fechada para os problemas c, d, e, do exemplo acima.

{zwsp} +
*Solução:*
c) Temos uma progressão aritmética de latexmath:[$n$] termos,
primeiro termo (chamado de latexmath:[$S(1)$]) 1, e razão 1, e a
fórmula da soma dos termos de uma P.A. nos dá

[width="90%", cols="1<,4<", grid="none", frame="none"]
|====
|latexmath:[$S(n) = \frac{n(1+n)}{2}$] |para latexmath:[$n \geq 1$]
|====

d) Temos uma progressão geométrica de latexmath:[$n+1$] termos,
primeiro termo (chamado latexmath:[$M_0$]) 64, e quociente
latexmath:[$1,15$], e a fórmula da soma dos termos de uma P.G. nos
dá

[width="90%", cols="2<,1<", grid="none", frame="none"]
|====
|latexmath:[$64\frac{(1,15^{n+1} - 1)}{(1,15 - 1)} = 64
\frac{(1,15^{n+1} - 1)}{0,15} = 426,667(1,15^{n+1} - 1)$] |para
latexmath:[$n \geq 0$]
|====

e) A resposta é latexmath:[$\frac{(3n^2)}{2} + \frac{7n}{2} - 4$].
Bem, é bastante fácil você verificar que a resposta está correta
para qualquer latexmath:[$n$] relativamente pequeno
latexmath:[$(1,2,3,4,5,6,\ldots)$]; dentro de poucas páginas você
aprenderá a provar por indução que a fórmula é válida para todo
natural não nulo; mas o mais difícil é como chegar ao começo de
tudo, isto é, como ``adivinhar'' que a resposta, a fórmula fechada,
é essa. Isso você só começará a ver, de leve, no exemplo 7, e,
em casos mais difíceis (como o problema 2, muito difícil), talvez
no mestrado, em cursos sobre Análise de Complexidade de Algoritmos
(método de adivinhação inteligente, substituição, árvores de
recorrência, etc.)

====

[[ex-hanoi]]
.{zwsp}
====
Considere o algoritmo recursivo abaixo, para o conhecido problema da
Torre de Hanói (não se preocupe nada com a linguagem, com detalhes,
só se preocupe com a ideia principal, geral e superficial do
algoritmo. E nem se preocupe em entender bem o algoritmo e seu
funcionamento real, a baixo nível. Basta que você se concentre em
contar cada movimento de um só disco.

----
procedure Hanói(De, Para, Aux, n):
         se n>1 então Hanói(De,Aux,Para,n-1)
                     mova disco de De para Para
                     Hanói(Aux,Para,De,n-1)
         senão mova disco do topo de De para Para
----

Quais as equações de recorrência para o tempo de execução?
(Repetimos: assuma que basta contar os movimentos dos discos)

{zwsp} +
*Solução:*

Pelo exame do algoritmo (pense bem, examinando-o), concluímos que as
equações de recorrência são:

[width="80%",cols="2<,<",grid="none",frame="none"]
|====
|latexmath:[$T(n) = T(n-1) + 1 + T(n-1) = 2T(n-1) + 1$] |caso
latexmath:[$n>1$]
|latexmath:[$T(n) = 1$]
			|caso latexmath:[$n=1$]
|====
====

.{zwsp}
====
Um procedimento recursivo consome 1 unidade de tempo se o tamanho
(latexmath:[$n$]) do problema é 1. Caso contrário, o procedimento
divide o problema de tamanho latexmath:[$n$] em 3 partes de tamanhos
os mais iguais possíveis a latexmath:[$n/3$], resolve-os
recursivamente, depois ajunta as soluções parciais formando a
solução mais geral, e gasta um tempo latexmath:[$n \log_{3}{n}$]
para fazer a divisão mais a junção. Quais as equações de
recorrência para o tempo de execução deste algoritmo?

{zwsp} +
*Solução:*

[width="80%",cols="<,<",grid="none",frame="none"]
|====
|latexmath:[$T(n) = 1$]
	|caso latexmath:[$n=1$]
|latexmath:[$T(n) = 3T(n/3) + n \log_{3}{n}$] 	|caso
latexmath:[$n>1$]
|====
====

.{zwsp}
====
Eis o algoritmo para pesquisa binária por um valor `Chave` em um
arranjo ordenado `A[]` cujo menor índice é `IMin` e maior índice
é `IMax`. Se a pesquisa encontrar `Chave`, retorna a posição onde
a encontrou:

[source,c]
----
int PesqBinaria(int A[], int Chave, int IMin, int IMax)
 {
   // teste se o arranjo está vazio
   if (IMax < IMin):
     // o arranjo está vazio, portanto retorne algo que
     // signifique que Chave não foi encontrada
     return Chave_NÃO_ENCONTRADA;
   else
     {
       // calcule o ponto central, para dividir a
       // faixa do arranjo em duas metades
       int IMeio = (IMin + IMax) divisãointeira 2;

       // comparação que tem 3 possibilidades
       if (A[IMeio] > Chave)
         // Chave está na metade mais baixa da faixa de A
         return PesqBinaria(A, Chave, IMin, IMeio-1);
       else if (A[IMeio] < Chave)
         // Chave está na metade mais alta da faixa de A
         return PesqBinaria(A, Chave, IMeio+1, IMax);
       else
         // Chave foi encontrada
         return IMeio;
    }
 }
----

Quais as equações de recorrência para o tempo de execução deste
algoritmo? Assuma que só o que importa é o tempo de comparação.

{zwsp} +
*Solução:*

[width="80%",cols="<,<",grid="none",frame="none"]
|====
|latexmath:[$T(1) = 1$] 				|
|latexmath:[$T(n) = T(teto(n/2)) + 1$] 	|para latexmath:[$n>1$]
|====
====

.{zwsp}
====
Procure a definição recursiva do algoritmo de ordenação
`MergeSort`, e escreva as equações de recorrência para seu tempo
de execução, considerando que só importa o tempo das comparações.

{zwsp} +
*Solução:*

[width="80%",cols="<,<",grid="none",frame="none"]
|====
|latexmath:[$T(1) = 1$] 			|
|latexmath:[$T(n) = 2T(n/2) + n$] 	|para latexmath:[$n>1$]
|====
====

=== Provas pelo Princípio da Indução Matemática Simples (ou Fraca)

TIP: Estão disponíveis videoaulas sobre Indução na <<tabqr_inducao>>.

.Analogia com escada
====
Dada uma escada de infinitos degraus, para que se alcance um qualquer
degrau latexmath:[$n$] (que não está abaixo de um dado degrau
latexmath:[$n_0$]), basta que:

. o degrau latexmath:[$n_0$] seja alcançado;
. qualquer que seja latexmath:[$k$] não abaixo de latexmath:[$n_0$],
se o degrau latexmath:[$k-1$] for alcançado, isto implica que o
degrau latexmath:[$k$] também o será.
====

.Analogia com dominós caindo em fila
====
Dados infinitos dominós em fila, para eles caírem em sequência e
derrubarem uma qualquer peça latexmath:[$n$] (que não está antes
que uma dada peça latexmath:[$n_0$]) basta que:

. o dominó latexmath:[$n_0$] seja derrubado;
. qualquer que seja latexmath:[$k$] não abaixo de latexmath:[$n_0$],
se o dominó latexmath:[$k-1$] cair derrubará o dominó
latexmath:[$k$].
====

==== Princípio de Indução Matemática (Simples, Fraca) (P.I.M. versão I)

Seja latexmath:[$P$] uma proposição (isto é, a afirmação de
uma propriedade) definida nos inteiros não negativos. Se pudermos
provar que: +
(i) para um dado inteiro não negativo latexmath:[$n_0$], a
proposição a ele associada (i.e, a proposição
latexmath:[$P(n_0)$]) é verdadeira; e +
(ii) para qualquer inteiro latexmath:[$m > n_0$], a suposição de
que a preposição associada ao inteiro latexmath:[$m-1$] (i.e, a
proposição latexmath:[$P(m-1)$]) é verdadeira implicará que a
preposição associada ao inteiro latexmath:[$m$] (i.e,
latexmath:[$P(m)$]) também é verdadeira, +
então concluímos que é verdadeira a proposição aplicada a todo
inteiro latexmath:[$n \geq n_0$] (i.e, latexmath:[$P(n)$]).

NOTE: (i) é chamada de ``passo base ou latexmath:[$P(n0)$]''; a
suposição em (ii) é chamada de ``hipótese indutiva ou
latexmath:[$P(n-1)$]''; e a implicação em (ii) é chamada ``passo
indutivo ou latexmath:[$P(n)$]''. Usualmente (mas não
necessariamente), latexmath:[$n_0$] é 1 ou 0

==== Princípio de Indução Matemática (Simples, Fraca) (P.I.M. versão II)
equivalente à versão I, acima. Você sempre pode usar a
versão que preferir, portanto só precisa aprender e usar uma delas:
+
Seja latexmath:[$P$] uma proposição definida nos inteiros não
negativos. Se pudermos provar que: +
(i) para um dado inteiro não negativo latexmath:[$n_0$],
latexmath:[$P(n_0)$] é verdadeira; e +
(ii) para qualquer inteiro latexmath:[$m \geq n_0$], a suposição de
que latexmath:[$P(m)$] é verdadeira implicará que
latexmath:[$P(m+1)$] também é verdadeira, +
então concluímos que latexmath:[$P(n)$] é verdadeira para todo
latexmath:[$n \geq n_0$].

.{zwsp}
====
Você está procurando descobrir uma fórmula para a soma dos
primeiros latexmath:[$n$] números ímpares. Para talvez lhe ajudar a
descobrir algum tipo de regularidade ou algo semelhante, você
rascunhou a tabela tendo, onde, em cada coluna, a 1ª linha dá o
valor de latexmath:[$n$], a 2ª linha dá o latexmath:[$n$]-ésimo
ímpar, e a 3ª linha dá a dita soma,

[width="100%",cols="<,<,<,<,<,<,^,<",options="header"]
|====
|latexmath:[$n$] |0 |1 |2 |3 |4 |latexmath:[$\cdots$] |latexmath:[$n$]
|latexmath:[$n$]-ésimo ímpar |não existe |1 |3 |5 |7
|latexmath:[$\cdots$] |latexmath:[$2n-1$]
|latexmath:[$S(n)$], a soma latexmath:[$1+3+5+7+\cdots +(2n+1)$] |0
|latexmath:[$1=1$]
|latexmath:[$1+3=4=9=n^2$]|latexmath:[$1+3+5=9=n^2$]
|latexmath:[$1+3+5+7=16=n^2$] |latexmath:[$\cdots$]
|latexmath:[$n^2$] (CONJECTURA)
|====

Analisando a tabela, você percebe que, para latexmath:[$n$] igual a
latexmath:[$0,1,2,3,4$], a soma sempre é igual a latexmath:[$n^2$].
Será isso uma coincidência? Valerá isto para qualquer inteiro não
negativo latexmath:[$n$]? Você forma, em sua mente, a conjectura de
que é verdadeira a proposição latexmath:[$P(n)$] definida como
``para qualquer inteiro não negativo latexmath:[$n$], a soma
latexmath:[$S(n)$] dos primeiros latexmath:[$n$] números ímpares
(i.e, latexmath:[$1 + 3 + 5 + \cdots + (2n - 1)$] é igual a
latexmath:[$n^2$]''. Provemos esta conjectura, usando o P.I.M.
versão I.

. Para latexmath:[$n_0 = 0$], a proposição latexmath:[$P(n_0)$] é
verdadeira porque ela leva a latexmath:[$S(n_0) = S(0) = n_{0}^{2} =
0^2 = 0$], que concorda com a definição de que a soma dos primeiros
0 elementos de qualquer sequência é 0;
. para qualquer inteiro latexmath:[$m > n_0$], façamos a hipótese
de que latexmath:[$P(m-1)$] é verdade, i.e, latexmath:[$S(m-1) =
1+3+5+ \cdots + (2(m-1)-1) = (m-1)^2$] . Então

[width="100%", cols="1<,10<,5<", frame="none",grid="none"]
|====
|latexmath:[$S(m)$] |latexmath:[$= [1+3+5+ \cdots + (2(m-1)-1)\] +
(2m-1) = S(m-1) + (2m-1)$] |_Por definição de latexmath:[$S(m-1)$]_
| |latexmath:[$= (m-1)^2 + (2m-1)$] |_pela hipótese indutiva,
aplicada a latexmath:[$S(m-1)$]_
| |latexmath:[$= m^2 - 2m + 1 +2m-1$] |_algebrismo simples:
latexmath:[$(a-b)^2 = a^2 - 2ab + b^2$]_
| |latexmath:[$= m^2$] |portanto a latexmath:[$P(m)$] é verdadeira
|====

Portanto, uma vez que provamos as etapas 1 e 2, então, pelo
Princípio de Indução Matemática (versão I), a proposição está
provada. C.Q.D. (Como se Queria Demonstrar).
====

.{zwsp}
====
Sr. ``Intuitivo'' (nada preciso nem científico) fez muitas contas e
verificou que, para latexmath:[$n = 0,1,2,3, \ldots , 40$], sempre
resultou que latexmath:[$f(n) = n^{2}-n+41$] é um número primo
(isto é, que só é divisível por 1 e por si mesmo). Daí, numa
``indução caipira'', ele diz que ``provou'' que isto sempre é
verdadeiro. Pode você ajudá-lo por realmente provar sua conjectura?
Ou por achar um contraexemplo que a refute?
Bem, a proposição dele é ``para qualquer inteiro não negativo
latexmath:[$n$], latexmath:[$f(n) = n^{2}-n+41$] é um número
primo.'' Tentemos provar esta conjectura.

. Para latexmath:[$n_0 = 0$], a proposição latexmath:[$P(n_0)$] é
verdadeira porque latexmath:[$f(0) = 0^{2} - 0 + 41 = 41$], que
realmente é primo (porque testamos e vimos que não é divisível
por nenhum inteiro entre latexmath:[$2 \mbox{ e } 41-1=40$]);
. *para qualquer inteiro latexmath:[$m > n_0$], façamos a hipótese*
de que latexmath:[$f(m-1) = (m-1)^{2}-(m-1)+41 = m^{2}-2m+1 - m+1 +
41 = m^{2}-3m+43$] é primo. Então latexmath:[$f(m) = m^{2}-m+41$]
pode ser calculado em função de latexmath:[$f(m-1)$] como
latexmath:[$f(m) = f(m-1)+2m-2$] e deveria sempre ser primo para a
prova prosseguir, mas isso não é verdade para latexmath:[$m = 41$]:
embora latexmath:[$f(40) = 402-40+41 = 1601$] seja primo,
latexmath:[$f(41) = f(41-1)+2 \times 41-2 = 1601+82-2 = 1681 = 412$],
que não é primo. Portanto, não pudemos usar o P.I.M.-I para provar
a conjectura, e descobrimos que latexmath:[$n=41$] é um
contraexemplo que a refuta.
====

.{zwsp}
====
(``bolas de golfe''): Começamos com 4 recipientes que contêm
quantidades conhecidas de bolas de golfe. Um ``movimento legal'' é
definido como removendo 1 bola de cada um de três quaisquer dos
recipientes e colocando essas 3 bolas no recipiente restante. Por
exemplo, se os 4 recipientes contêm 10, 12, 14, 16 bolas, então o
resultado de um dos 4 ``movimentos legais'' possíveis seria 13, 11,
13, 15. A questão é: dada uma distribuição inicial, é possível,
através de uma sequência de ``movimentos legais'', chegar a uma
distribuição que tenha o mesmo número de bolas em cada recipiente?
Assim, no exemplo, poderíamos nós chegar a 13, 13, 13, 13? Sua
tarefa é usar o P.I.M.-II para determinar uma condição, ou
conjunto de condições, sobre a distribuição inicial, que
permitirá o jogo ser ganho.

{zwsp} +
*Solução:*

Sejam (latexmath:[$n_1, n_2, n_3, n_4$]) os números naturais de
bolas nos quatro recipientes.

Depois de muito pensar e fazer experimentos usando lápis e papel,
formulamos a conjectura: A condição necessária e suficiente para o
jogo terminar (com sucesso, claro!) é que, no início, o valor
absoluto da diferença entre os números de bolas entre dois
recipientes quaisquer seja múltiplo de 4 (note que isto implica que
a soma dos números de bolas nos quatro recipientes seja múltiplo de 4).

A prova é por indução sobre o número (latexmath:[$n$]) de jogadas
necessárias para se chegar à solução.

* *Passo base* (latexmath:[$n = 0$]): Uma solução é da forma
latexmath:[$(x,x,x,x)$] (onde latexmath:[$x$] é qualquer natural),
evidentemente satisfazendo a condição da conjectura.
* *Hipótese Indutiva* (latexmath:[$n=m$]): Suponhamos que a
condição da tese vale para latexmath:[$n=m$], onde latexmath:[$m$]
é um natural qualquer, isto é: estamos com um estado
(latexmath:[$n_1,n_2,n_3,n_4$]) que dista latexmath:[$m$] jogadas da
solução, e latexmath:[$|(n_1-n_2)|, |(n_1-n_3)|, |(n_1-n_4)|,
|(n_2-n_3)|, |(n_2-n_4)|, \mbox{ e } |(n_3-n_4)| $] são múltiplos
de 4.

Só nos resta provar que as condições da conjectura também valem
para latexmath:[$m+1$].

* *Passo indutivo* (latexmath:[$n=m+1$]): Ora, há 4 estados que
podem ter sido os anteriores do atual. O primeiro, que corresponde a
termos movido as 3 bolas para o 4º recipiente, é
(latexmath:[$n_1-1, n_2-1, n_3-1, n_4+3$]), e você pode checar que
este estado ainda satisfaz as 6 equações na hipótese indutiva,
isto é, satisfaz a condição da conjectura. Semelhantemente para os
outros 3 estados possíveis de ter sido anteriores ao atual
(obviamente, devem ser descartados os estados que tenham um dos
recipientes com número negativo de bolas). C.Q.D.
====

.Soma dos termos de uma P.A.
====
Dada a progressão aritmética

[latexmath]
++++
\[a_1, a_2, \ldots, a_n,\]
++++

onde latexmath:[$a_i = a_1 + (i-1)r$] para um certo
latexmath:[$a_1$], um certo latexmath:[$r$], e para todo inteiro
latexmath:[$i$] no intervalo latexmath:[$[1,n\]$], prove por
*Indução Matemática Simples (ou Fraca)* a conjectura:

[quote]
``a soma latexmath:[$(a_1 + a_2 + \cdots + a_n)$] dos latexmath:[$n$]
primeiros termos da P.A., simbolizada por latexmath:[$S(n)$], é dada
por latexmath:[$S(n) = (n/2)(a_1+a_n)$]'' {sp}{sp}{sp}		`(C)`

{zwsp} +
*Solução:*

* *Etapa Base* (latexmath:[$n=1$]): A definição de soma de uma
sequência de 1 só elemento resulta que latexmath:[$S(n) = a_1$], e
a fórmula (C) também resulta que latexmath:[$S(n) = (1/2)(a_1+a_1)
= a1$], portanto `(C)` é válida.
* *Hipótese Indutiva* (latexmath:[$n=m-1$]): Suponhamos que `(C)` é
válida para latexmath:[$m-1$], onde latexmath:[$m$] é um qualquer
inteiro latexmath:[$m>1$]: +
[width="60%", cols="2>, 6<, 1<",grid="none",frame="none"]
|====
|latexmath:[$S(m-1)$] |latexmath:[$=
(\frac{(m-1)}{2})(a_1+a_{m-1})$]	|(H)
|====

ou, equivalentemente, +
[width="70%", cols="2>, 6<, 1<",grid="none",frame="none"]
|====
|latexmath:[$S(m-1)$] |latexmath:[$=
\left(\frac{1}{2}\right)(m-1)(a_1+ (a_1 + (m-2)r))$] |
|					  |latexmath:[$=
\left(\frac{1}{2}\right)(m-1)(2a_1+ (m-2)r)$]		 |(H’)
|====

Só nos falta provar que (C) também é válida para latexmath:[$m$].

* *Etapa Indutiva* (latexmath:[$n=m$]):

[width="100%", cols="1>, 10<, 4<",grid="none",frame="none"]
|====
|latexmath:[$S(m)$] |latexmath:[$= S(m-1)+ a_m$] |
| |latexmath:[$= \left(\frac{1}{2}\right)(m-1)(2a_1 + (m-2)r) + a_m$]
|(usando H’)
| |latexmath:[$= \left(\frac{1}{2}\right)(m-1)(2a_1 + (m-2)r) +
(a_1+(m-1)r)$] |(usando a definição de latexmath:[$a_m$])
| |latexmath:[$= \left(\frac{1}{2}\right)(m-1)(2a_1+ (m-1-1)r) +
a_1+(m-1)r$] |(``Truque'' que uma vez esqueci de usar em uma aula de
improviso)
| |latexmath:[$= \left(\frac{1}{2}\right)(m-1)(2a_1+ (m-1)r) -
\left(\frac{1}{2}\right)(m-1)r + a_1+(m-1)r$] |
| |latexmath:[$= \left(\frac{1}{2}\right)(m-1)(2a_1+ (m-1)r) +
\left(\frac{1}{2}\right)(m-1)r + a_1$] |(colocando
latexmath:[$(m-1)r$] em evidência)
| |latexmath:[$= \left(\frac{1}{2}\right)(m-1)(2a_1+ (m-1)r) +
\left(\frac{1}{2}\right)(2a_1+(m-1)r)$] |
| |latexmath:[$=
\left(\left(\frac{1}{2}\right)(m-1)+\frac{1}{2}\right)(2a_1+
(m-1)r)$] |(colocando latexmath:[$(2a_1+(m-1)r)$] em evidência)
| |latexmath:[$= \left(\frac{1}{2}\right)(m)(2a_1+ (m-1)r)$] |
| |latexmath:[$= \left(\frac{1}{2}\right)(m)(a_1+ (a_1 + (m-1)r))$]
|(usando o ``truque'' latexmath:[$2a_1=a_1+a_1$])
| |latexmath:[$= \left(\frac{1}{2}\right)(m)(a_1+a_m)$] |
|====

Portanto, `(C)` também é válida para latexmath:[$m$], C.Q.D.
====

.{zwsp}
====
Considere as equações de recorrência (correspondentes à
complexidade temporal de um algoritmo recursivo chamado de
latexmath:[$MaxMin$], que determina quais são o maior e o menor
elemento de um conjunto com latexmath:[$n \geq 2$] elementos):

[width="90%",cols="<,2<",frame="none",grid="none"]
|====
|latexmath:[$T(n) = 1$] |para latexmath:[$n=2$];
|latexmath:[$T(n) = 2T(n/2) + 2$] |caso latexmath:[$n>2$]
|====

Use o *Princípio de Indução Matemática* (pode ser a versão II)
para provar a conjectura, que é esta: ``para todo latexmath:[$n>2$],
latexmath:[$T(n) = 3n/2 - 2$]''.

* Mude a variável por uma que torne as coisas mais simples, com
todas as divisões inteiras. Isto é, considere, por simplicidade,
que latexmath:[$n = 2^i$], para algum latexmath:[$i$] nos naturais
positivos (latexmath:[$i \geq 1$], portanto latexmath:[$n \geq 2$]);
depois, ao invés de fazer indução sobre latexmath:[$n$], faça-a
sobre latexmath:[$i$].

{zwsp} +
*Solução:*

Por facilidade (evitando divisões não inteiras), mudemos a
variável para latexmath:[$i$], onde latexmath:[$n = 2^i$]. As
equações de recorrência ficam sendo

[width="90%",cols="<,2<",frame="none",grid="none"]
|====
|latexmath:[$T(2^i) = 1$]					|para
latexmath:[$i=1$];
|latexmath:[$T(2^i) = 2T(2^{i-1}) + 2$]		|caso
latexmath:[$i>1$]
|====

e a conjectura que queremos provar fica sendo ``para todo
latexmath:[$i>1, T(2^i) = (3\times 2^{i-1}) - 2$]''.

{zwsp} +
Um modo de provar:

* *Passo base*: latexmath:[$(i=1)$]: pela definição recursiva, já
temos que latexmath:[$T(21) = 1$]. A conjectura é verdadeira porque
também resulta em latexmath:[$(3 \times 2^{1-1}) -2) = 3-2 = 1$].
* *Passo indutivo*: Seja um qualquer inteiro latexmath:[$i>1$].
Assumamos que a conjectura vale para latexmath:[$i-1$], isto é,
latexmath:[$T(2^{i-1}) = (3\times 2^{i-2}) - 2$]. Agora, só
precisamos provar que a conjectura é verdadeira para
latexmath:[$i$]. Tomemos a equação de recorrência
latexmath:[$T(2^i) = 2T(2^{i-1}) + 2$]. Apliquemos aqui a hipótese
indutiva, resultando em latexmath:[$T(2^i) = 2((3 \times 2^{i-2}) -
2)+ 2 = 3\times 2^{i-1} - 4 +2 = 3\times 2^{i-1} -2$]. A conjectura
vale para latexmath:[$i$]. C.Q.D.

{zwsp} +
Outro modo de provar:

* *Passo base* (latexmath:[$i = 1$]) (portanto, latexmath:[$n = 2$])
+
A conjectura é válida, pois ela resulta em latexmath:[$3\times 2/2 - 2
= 1$], o que concorda com a 1ª equação de recorrência.

* *Hipótese Indutiva* (latexmath:[$i=k$]): suponhamos que a conjectura
vale para um certo latexmath:[$i=k$], isto é latexmath:[$T(2^k) =
3\times (2^k)/2 - 2$].

Agora, só temos que provar que a conjectura vale para
latexmath:[$i=k+1$].

* *Passo indutivo* (latexmath:[$i = k+1$]) (isto é, latexmath:[$S$]
tem latexmath:[$2n = 2^{k+1}$] elementos):

[width="90%",cols="1>,5<,5<",frame="none",grid="none"]
|====
|latexmath:[$T(2n)$] |latexmath:[$= 2T(n) + 2$] |(pela 2ª equação
de recorrência)
| |latexmath:[$= 2\times \left(3\times \frac{(2^k)}{2} - 2 \right) +
2$] |(pela hipótese indutiva)
| |latexmath:[$= \left(3 \times \frac{(2^{k+1})}{2} - 4\right) + 2$] |
| |latexmath:[$= 3 \times \frac{(2^{k+1})}{2} - 2 |
|====

C.Q.D.

{zwsp} +
Note como ambas as provas equivalem a termos provado (voltando à
variável latexmath:[$n$]): latexmath:[$T(n) = 3n/2 - 2$].
====

.{zwsp}
====
Seja a seguinte recorrência:

[latexmath]
++++
\[T(n) = \mbox{ se } n = 1 \mbox{ então } 1 \mbox{ senão } 3T(n
\mbox{ divisãointeira } 2) + n\]
++++

Funções descontínuas tais como a função piso (implícita na
divisãointeira) são difíceis de analisar, portanto comecemos nos
restringindo a latexmath:[$n$] ser uma exata potência de 2 (
expoente é um natural):

[latexmath]
++++
\[T(2^k) = \mbox{ se } k = 0 \mbox{ então } 1 \mbox{ senão }
3T(2^{k-1}) + 2^k\]
++++

Pode você formar uma conjectura para uma solução (uma fórmula
fechada, direta, sem recursão nem somatório nem produtório, mas,
sim, ``simples e direta'')? Pode prová-la por indução?

{zwsp} +
*Solução:*

{zwsp} +
Primeiro, tabulemos:

[width="90%", cols="<,<,<,<,<,<,<,^", options="header"]
|====
^|latexmath:[$n$] ^|1 ^|2 ^|4 ^|8 ^|16 ^|32 |latexmath:[$\ldots$]
|latexmath:[$T(n)$] |1 |5 |19 |65 |211 |665 |latexmath:[$\ldots$]
|====

{zwsp} +
Segundo, após muitas tentativas, achamos regularidade ao guardarmos
uma grande quantidade de ``história'':

[width="100%", cols="2<,1<,3<,4<,8<,8<,8<,1^", options="header"]
|====
^|latexmath:[$n$] ^|latexmath:[$2^0$] ^|latexmath:[$2^1$]
^|latexmath:[$2^2$] ^|latexmath:[$2^3$] ^|latexmath:[$2^4$]
^|latexmath:[$2^5$] |latexmath:[$\ldots$]
|latexmath:[$T(n)$] |latexmath:[$1$] |latexmath:[$3 \times 1 + 2$]
|latexmath:[$3^2 \times 1 + 3 \times 2 + 2^2$] |latexmath:[$3^3
\times 1 + 3^2 \times 2 + 3^1 \times 2^2 + 2^3$] |latexmath:[$3^4
\times 1 + 3^3 \times 2 + 3^2 \times 2^2 + 3 \times 2^3 + 2^4$]
|latexmath:[$3^5 \times 1 + 3^4 \times 2 + 3^3 \times 2^2 + 3^2
\times 2^3 + 3 \times 2^4 + 2^5$] |latexmath:[$\ldots$]
|====

{zwsp} +
Terceiro, concebemos a conjectura generalizante:

latexmath:[$T(2^k) = \sum_{i=0}^{k} \left( 3^{k-i} \times 2^i
\right)$], que _parece_ (mas teremos que provar a conjectura) a soma
dos latexmath:[$(k+1)$] primeiros termos de uma p. geométrica de
primeiro termo latexmath:[$1$] e quociente latexmath:[$2/3$].
Portanto, pela conhecida fórmula para essa soma, latexmath:[$T(2^k)
= \frac{3^{k}(1-(2/3)^{k+1})}{(1-(2/3))} = 3^{k+1} - 2^{k+1}$].

{zwsp} +
Quarto, provamos a conjectura

[latexmath]
++++
\[T(2^k) = 3^{k+1} - 2^{k+1} \; (\#)\]
++++

por indução matemática:

* *Passo base* (latexmath:[$k=0$]): O valor da fórmula (#) coincide
com a realidade (expressa na tabela) quando latexmath:[$k=0$].
* *Hipótese Indutiva* (latexmath:[$k=m$]): Suponhamos que (#) é
válida para um inteiro qualquer, latexmath:[$m$], tal que
latexmath:[$m \geq 1: T(2^m) = 3^{m+1} - 2^{m+1}$].
* *Passo indutivo* (latexmath:[$k=m+1$]): Quando latexmath:[$k =
m+1$], a recorrência resulta em latexmath:[$T(2^{m+1}) = 3T(2^m) +
2^{m+1}$]

Usando a hipótese indutiva, temos

[latexmath]
++++
\[T(2^{m+1}) = 3 \times (3^{m+1} - 2^{m+1}) + 2^{m+1} = 3^{m+2} -
2^{m+2}\]
++++

{zwsp} +
Portanto, a conjectura também é válida para latexmath:[$k=m+1$].

* *Conclusão*: (#) está provada, por indução matemática.
====

.{zwsp}
====
Prove que a soma dos latexmath:[$n$] primeiros naturais, isto é
latexmath:[$1+2+3+ \cdots +n$], é dada pela fórmula
latexmath:[$\sum_{k=1}^n k = \frac{n(n+1)}{2}$].

{zwsp} +
*Solução:*

* *Passo base* (latexmath:[$n =1$]): O lado esquerdo da fórmula a
provar resulta em 1. O lado direito também resulta em latexmath:[$1
\times 2/2 = 1$]. Portanto, a fórmula vale para latexmath:[$n=1$].
* *Hipótese Indutiva* (latexmath:[$n=m$]): suponhamos que a fórmula
a provar vale para latexmath:[$n$] igual a um certo natural
latexmath:[$m$], qualquer. Isto é: latexmath:[$\sum_{k=1}^m k =
\frac{m(m+1)}{2}$].
* *Passo indutivo* (latexmath:[$n=m+1$]):

[width="90%",cols="1>,3<, 3<",frame="none",grid="none"]
|====
|latexmath:[$sum_{k=1}^{m+1} k$] | latexmath:[$= \sum_{k=1}^m k +
(m+1)$] |
| |latexmath:[$= \frac{m(m+1)}{2} + (m+1)$] |(pela hipótese indutiva)
| |latexmath:[$= (m+1) \left( \frac{m}{2} + 1 \right)$] |(colocamos
latexmath:[$(m+1)$] em evidência)
| |latexmath:[$= (m+1) \left( \frac{(m+2)}{2} \right)$] |(reduzimos
latexmath:[$m/2 + 1$] ao mesmo denominador)
| |latexmath:[$= (m+1)(\frac{((m+1)+1)}{2})$] |(ora, para qualquer
latexmath:[$x$], temos latexmath:[$x+2 = x+1+1$]
|====

Portanto, a fórmula a provar vale para latexmath:[$n = m+1$].

Portanto, pelo princípio de indução matemática, a fórmula está
provada para todo latexmath:[$k \geq 1$].
====

.{zwsp}
====
Pelo exame do algoritmo da Torre de Hanói (<<ex-hanoi>>),
concluímos que as equações de recorrência são:

[width="90%",cols="3<,1<,1<",frame="none",grid="none"]
|====
|latexmath:[$T(n) = T(n-1) + 1 + T(n-1) = 2T(n-1) + 1$] |caso
latexmath:[$n>1$] |(1)
|latexmath:[$T(n) = 1$]
			|caso latexmath:[$n=1$] |(2)
|====

Prove é que a solução para as equações acima é

[latexmath]
++++
\[T(n) = 2^n - 1 \; \mbox{ (3)}\]
++++

{zwsp} +
*Solução:*

* *Passo base*(latexmath:[$n=1$]): Para latexmath:[$n=1$], a
equação (2) produz latexmath:[$1$], e a tese (3) produz o mesmo
valor: latexmath:[$2^1 - 1 = 2 - 1 = 1$].
* *Hipótese Indutiva*(latexmath:[$n = m$], onde latexmath:[$m$] é
um natural qualquer): Assumamos que, para latexmath:[$m$] um natural
qualquer, a tese vale, isto é:

[latexmath]
++++
\[T(m) = 2^m - 1 \; \mbox{ (4)}\]
++++

* *Passo indutivo*(latexmath:[$n=m+1$]):

[width="90%",cols="1>,3<,3<",grid="none",frame="none"]
|====
|latexmath:[$T(m+1)$] |latexmath:[$= T(m+1-1) + 1 + T(m+1-1)$] |(pelo
exame do algoritmo, ou de (1))
| |latexmath:[$= 2T(m) + 1$] |
| |latexmath:[$= 2 \times (2^m - 1) +1$] |(por (4))
| |latexmath:[$= 2^{m+1} - 2 + 1$] |
| |latexmath:[$= 2^{m+1} - 1$] |
|====

Portanto, (3) também vale para latexmath:[$m+1$].

* *Conclusão*: o teorema está provado, pelo Princípio da Indução
Matemática
====

.{zwsp}
====
Pode você vislumbrar a fórmula fechada para a soma dos cubos dos
latexmath:[$n$] primeiros naturais (latexmath:[$1,2,3,\ldots$])? Isto
é, para latexmath:[$S(n) = 1^3 + 2^3 +3^3 + \cdots +n^3$]? E pode
prová-la?

{zwsp} +
*Solução:*

Depois de alguns experimentos, formulamos a conjectura de que a soma
dos cubos dos latexmath:[$n$] primeiros naturais é +
[latexmath]
++++
\[S(n) = \frac{n^2(n+1)^2}{4} \; \mbox{ (1)}\]
++++

* *Passo base*(latexmath:[$n=1$]): (1) é válida porque seu lado
esquerdo é latexmath:[$1$] (por constatação direta) e seu lado
direito também é latexmath:[$1$], pois latexmath:[$(1^2(1+1)^2)/4 =
(1 \times 4) / 4 = 1$].
* *Hipótese Indutiva*(latexmath:[$n = k$]): suponhamos que (1) é
válida para latexmath:[$n = k$]. Isto é, +
[latexmath]
++++
\[S(k) = \frac{k^2(k+1)^2}{4} \; \mbox{ (2)}\]
++++

* *Passo indutivo*(latexmath:[$n = k+1$]): +

[width="100%", cols="1>,3<,3<", frame="none",grid="none"]
|====
|latexmath:[$S(k+1)$] |latexmath:[$= \cdots = S(k) + (k+1)^3$]
|(aplicação da definição de latexmath:[$S$], e ajuntamento de
parcelas de soma).
|latexmath:[$\therefore S(k+1)$] |latexmath:[$= \left(
\frac{k^2(k+1)^2}{4} \right) + (k+1)^3$] |(pela hipótese indutiva,
(2))
|latexmath:[$\therefore S(k+1)$] |latexmath:[$= \frac{(k^2(k+1)^2 +
4(k+1)^3)}{4}$] |(reduzimos tudo ao mesmo denominador)
|latexmath:[$\therefore S(k+1)$] |latexmath:[$= (k+1)^2 \frac{(k^2 +
4(k+1))}{4}$] |(pusemos o fator latexmath:[$(k+1)^2 em evidência)$]
|latexmath:[$\therefore S(k+1)$] |latexmath:[$= (k+1)^2 \frac{(k^2 +
4k+4)}{4}$] |
|latexmath:[$\therefore S(k+1)$] |latexmath:[$= (k+1)^2
\frac{(k+2)^2}{4} = (k+1)^2 \frac{((k+1) + 1)^2}{4}$] |
.3+<|latexmath:[$\therefore$] a suposição que (1) é válida para
latexmath:[$n = k$] implica que também é válida para latexmath:[$n
= k+1$]
|====

Portanto, pelo Princípio de Indução Matemática, (1) está provada.
====

.{zwsp}
====
Tente usar o P.I.M. Simples (ou Fraca), acima visto, para provar que,
para todo latexmath:[$n \geq 2$], latexmath:[$n$] é um número primo
ou é um produto de números primos.

{zwsp} +
*Solução:*

O P.I.M. Simples não basta para a prova porque, na hipótese
indutiva, você supôs que a propriedade vale para latexmath:[$k-1$].
Depois, na etapa indutiva, no subcaso em que latexmath:[$n$] não é
primo mas sim um produto de primos, você chamou este produto de
latexmath:[$k = a \cdot b$], depois você chegou a provar que
latexmath:[$a,b$] têm que estar no intervalo fechado
latexmath:[$[2,k-1\]$], mas não pode usar a hipótese indutiva
porque ela só se refere a latexmath:[$k-1$], e latexmath:[$a,b$]
podem ser menores que isto.

Este problema foi proposto somente com o objetivo de mostrar que, às
vezes, você precisa de um princípio de indução mais completo e
forte, baseado em supor que muito mais coisas são verdadeiras abaixo
de latexmath:[$n$]. Espere, e verá este problema resolvido no
<<ex-pimc>>, abaixo.
====

=== Provas pelo Princípio de Indução Matemática Completa (ou Forte)

==== Princípio de Indução Matemática Completa (ou Forte) (P.I.M.C. versão I)
Seja latexmath:[$P$] uma proposição definida nos
inteiros não negativos. Se pudermos provar que, +
*(i)* para latexmath:[$k$] dados inteiros não negativo
latexmath:[$n_0, n_0+1, \ldots , n_0+k-1$], então as latexmath:[$k$]
proposições latexmath:[$P(n_0), P(n_0+1), \ldots, P(n_0+k-1)$] são
verdadeiras; e  +
*(ii)* para qualquer inteiro latexmath:[$n \geq n_0+k$], a
suposição de que as preposições latexmath:[$P(n-1), P(n-2),
\ldots , P(n-k)$] são verdadeiras implicará que a preposição
latexmath:[$P(n)$] também é verdadeira,+
então concluímos que a proposição latexmath:[$P(n)$] é verdade
para todo inteiro latexmath:[$n \geq n_0$].

[[ex-pimc]]
.{zwsp}
====
Seja latexmath:[$\{a_n\}$] é a sequência definida recursivamente
por latexmath:[$a_1 = 1, a_2 = 4, a_3 = 9, \mbox{ e } a_{n+1} =
3a_{n-3} a_{n-1} + a_{n-2}$] para todo latexmath:[$n \geq 3$]. Usando
o Princípio de Indução Matemática Completa, prove que
latexmath:[$a_n = n^2$].

{zwsp} +
*Solução:*

. Temos latexmath:[$n_0 = 1$] e latexmath:[$k = 3$]. +
Para latexmath:[$n = n_0 = 1$], aplicando a fórmula latexmath:[$P(n)
= n^2$], temos latexmath:[$P(1) = 1^2 = 1$], que coincide com
latexmath:[$a_1 = 1$]; +
Para latexmath:[$n = n_0 + 1 = 2$], aplicando a fórmula
latexmath:[$P(n) = n^2$], temos latexmath:[$P(2) = 2^2 = 4$], que
coincide com latexmath:[$a_2 = 4$]; +
Para latexmath:[$n = n_0 + k-1 = 3$], aplicando a fórmula
latexmath:[$P(n) = n^2$], temos latexmath:[$P(3) = 3^2 = 9$], que
coincide com latexmath:[$a_3 = 9$];
. Para qualquer inteiro latexmath:[$n \geq n_0 + k = 4$], a
suposição de que as preposições latexmath:[$P(n-1), P(n-2),
\ldots , P(n-k)$] são verdadeiras implicará que a preposição
latexmath:[$P(n)$] também é verdadeira, porque latexmath:[$P(n) =
3a_{n-1} - 3a_{n-2} + a_{n-3} = 3(n-1)^2 - 3(n-2)^2 + (n-3)^2 =
3n^2-6n+3 - 3n^2+12n-12 - n^2-6n+9 =  n^2$]

Então, pelo P.I.M.C. I, concluímos que a proposição
latexmath:[$P(n)$] é verdade para todo inteiro latexmath:[$n \geq
1$].
====

==== Princípio de Indução Matemática Completa (ou Forte) (P.I.M.C.  versão II)

Seja latexmath:[$P$] uma proposição definida nos
inteiros não negativos. Se pudermos provar que, +
*(i)* Para um dado inteiro não negativo latexmath:[$n_0$], a
proposições latexmath:[$P(n_0)$] é verdadeira; e +
*(ii)* Para qualquer inteiro latexmath:[$n > n_0$], a suposição de
que todas as preposições aplicadas aos números entre
latexmath:[$n_0$] e latexmath:[$n-1$] (isto é, todas
latexmath:[$P(n_0), P(n_0+1), P(n_0+2), \ldots , P(n-1)$]) são
verdadeiras implicará que a preposição latexmath:[$P(n)$] também
é verdadeira, +
então concluímos que a proposição latexmath:[$P(n)$] é verdade
para todo inteiro latexmath:[$n \geq n_0$].

.{zwsp}
====
Prove que é verdadeira a proposição latexmath:[$P(n)$]: ``para
todo latexmath:[$n \geq 2$], latexmath:[$n$] é um número primo ou
latexmath:[$n$] é um produto de números primos''

{zwsp} +
*Solução:*

* *Passo Base* (latexmath:[$n=2$]): latexmath:[$P(2)$] é verdadeira,
porque 2 é primo.
* *Hipótese Indutiva*: Assumamos que, para todo latexmath:[$2 \leq r
\leq k-1$], latexmath:[$P(r)$] é verdadeira.
* *Passo Indutivo* (latexmath:[$n=k$]): Analisemos latexmath:[$P(k)$]:
** *Caso 1*, latexmath:[$k$] é primo: então latexmath:[$P(k)$]
será verdadeira;
** *Caso 2*, latexmath:[$k$] não é primo: Como latexmath:[$k$] não
é primo, então pode ser escrito como o produto latexmath:[$k=a
\cdot b$], onde latexmath:[$2 \leq a \leq k-1$] e latexmath:[$2 \leq
b \leq k-1$]. Portanto, a hipótese indutiva se aplica tanto a
latexmath:[$a$] como a latexmath:[$b$], de modo que tanto
latexmath:[$a$] como latexmath:[$b$] são (cada um) primo ou produto
de primos. Portanto, latexmath:[$k= 1 \cdot b$] será um produto de
(pelo menos dois) primos. Logo, latexmath:[$P(k)$] é verdadeira.

Os casos 1 e 2 esgotam todas as possibilidades, portanto
latexmath:[$P(k)$] é verdadeira.

* *Conclusão*: Portanto, pelo princípio da Indução Matemática
Completa, latexmath:[$P(n)$] é verdadeira. C.Q.D.
====

.{zwsp}
====
Seja latexmath:[$P(n)$] a afirmativa ``latexmath:[$n$] pode ser
escrito como a soma de distintas potências de 2''.

{zwsp} +
*Solução:*

* *Passo Base* (latexmath:[$n=1$]): latexmath:[$P(1)$] é verdade,
uma vez que latexmath:[$1 = 2^0$].
* *Hipótese Indutiva* : Assuma que latexmath:[$P(j)$] é verdadeira
para todo inteiro positivo latexmath:[$j$], onde latexmath:[$1 \leq j \leq k$],
isto é, podemos escrever latexmath:[$j = 2^{p_1} + 2^{p_2} + 2^{p_3} + \cdots + 2^{p_t}$],
onde as potências latexmath:[$p_1 < p_2 < p_3 < \cdots < p_t$].
* *Passo Indutivo* (latexmath:[$n=k+1$]): Agora considere
latexmath:[$k+1$]. Temos dois casos:
** Caso 1: latexmath:[$k + 1$] é par. Então latexmath:[$k+1 = 2j$]
para algum latexmath:[$1 \leq j \leq k$] e assim, pela hipótese
indutiva, latexmath:[$k+1 = 2(2^{p_1} + 2^{p_2} + 2^{p_3} + \cdots +
2^{p_t})$], onde todas as potências ainda são distintas; e
** Caso 2: latexmath:[$k + 1$] é ímpar. Então latexmath:[$k$] é
par e, pela hipótese indutiva, podemos escrever latexmath:[$k =
2^{p_1} + 2^{p_2} + 2^{p_3} + \cdots + 2^{p_t}$], onde
latexmath:[$1 \leq p_1 < p_2 < p_3 < \cdots < p_t$]. (todas as potências têm
valor latexmath:[$\geq 1$], uma vez que latexmath:[$k$] é par). Mas
então latexmath:[$1+k = 2^0 + 2^{p_1} + 2^{p_2} + 2^{p_3} + \cdots +
2^{p_t}$], e todas as potências são diferentes.

Portanto, temos

. latexmath:[$P(1)$]
. latexmath:[$P(1) \wedge P(2) \wedge P(3) \rightarrow P(k+1)$].

Assim, pelo P.I.M. Completa, latexmath:[$P(n)$] é verdadeira para
todo inteiro positivo latexmath:[$n$].
====

.{zwsp}
====
Prove que a propriedade latexmath:[$P(n)$] definida como ``qualquer
inteiro positivo n maior ou igual a 8 pode ser representado como a
soma de números 3 e números 5''.

{zwsp} +
*Solução:*

* *Passo Base* (latexmath:[$n=8$]): Ora, latexmath:[$8 = 3+5$],
portanto latexmath:[$P(8)$] é verdadeira.
* *Hipótese Indutiva* (latexmath:[$n=k$]): Suponhamos que para
qualquer latexmath:[$r$] tal que
latexmath:[$8 \leq r \leq k$], latexmath:[$P(r)$] é verdadeira, isto
é, latexmath:[$r$] é a soma de números 3 e números 5.
* *Passo Indutivo* (latexmath:[$n=k+1$]):
** Caso latexmath:[$n = 9$]: latexmath:[$P(n)$] vale porque
latexmath:[$9 = 3+3+3$]
** Caso latexmath:[$n = 10$]: latexmath:[$P(n)$] vale porque
latexmath:[$10 = 5+5$]
** Caso latexmath:[$n \geq 11$]: Seja latexmath:[$n=k+3$] com
latexmath:[$k \geq 8$]. Pela hipótese indutiva, latexmath:[$P(k)$]
vale, isto é latexmath:[$k$] é uma soma de números 3 e de números 5.
Portanto, somando-se 3 a esta soma, teremos que latexmath:[$P(n)$]
também vale.

Estes são todos os casos possíveis e, neles, latexmath:[$P(n)$]
sempre valeu.

Portanto, pelo P.I.M.C., está provado o que queríamos provar.
====

=== Vídeos

include::videos/inducao.adoc[]


=== Atividades

. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 2n$]. Use
indução para provar a fórmula fechada latexmath:[$T(n) = 1n^2 + 1n + 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = -1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 2n$]. Use
indução para provar a fórmula fechada latexmath:[$T(n) = n^2 + n -
1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 2n -2$]. Use
indução para provar a fórmula fechada latexmath:[$T(n) = n^2 - n +
1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) - 2n + 2$]. Use
indução para provar a fórmula fechada latexmath:[$T(n) = -n^2 + n + 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = -1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 2n -2$]. Use
indução para provar a fórmula fechada latexmath:[$T(n) = n^2 - n -
1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = -1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) -2n + 2$]. Use
indução para provar a fórmula fechada latexmath:[$T(n) = -n^2 + n - 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 3n^2 -1n +1$].
Use indução para provar a fórmula fechada latexmath:[$T(n) = n^3 +
n^2 + n + 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 6n^2 -4n +2$].
Use indução para provar a fórmula fechada latexmath:[$T(n) = 2n^3 + n^2 + n + 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 3n^2 +1n +0$].
Use indução para provar a fórmula fechada latexmath:[$T(n) = n^3 +
2n^2 + n + 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 3n^2 -1n +2$].
Use indução para provar a fórmula fechada latexmath:[$T(n) = n^3 +
n^2 + 2n + 1$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 2$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 3n^2 -1n +1$].
Use indução para provar a fórmula fechada latexmath:[$T(n) = n^3 +
n^2 + n + 2$].
. Para latexmath:[$n = 0$] temos latexmath:[$T(n) = 1$]    e    para
latexmath:[$n > 0$] temos latexmath:[$T(n) = T(n-1) + 9n^2 -7n +3$].
Use indução para provar a fórmula fechada latexmath:[$T(n) = 3n^3 + n^2 + n + 1$].

=== Recapitulando

[NOTE]
====
Para você treinar ainda melhor, recomendamos a Lista de Exercícios
sobre Sequências e Indução Matemática, Prof. Loureiro,
http://goo.gl/STWqTS, com soluções em http://goo.gl/tWc8d6.
====

//_

Ótimo, você já concluiu o capítulo 3, já chegou quase à metade
da disciplina. Parabéns, não desista nunca, persevere, esforce-se
cada vez mais para vencer com honestidade, garra e competência, seja
um vencedor! Se você foi disciplinado e realmente ``suou'' estudando
4 a 8 h cada semana, deve ter aprendido a modelar os problemas de
Matemática e de programação através de equações recorrentes,
depois aprendido a formar uma conjectura para uma fórmula fechada
que as resolva, depois aprendido a provar essa conjectura por
Indução Matemática (quer Simples ou Completa), com toda precisão
e rigor. Essas coisas são muito interessantes e importantes.
Importantes porque há um fundo de verdade no dito ``até que você
bem aprenda a encontrar equações recorrentes para resolver seus
problemas, você não terá aprendido a bem programar. E até que
você bem aprenda a provar por Indução Matemática as fórmulas
fechadas que conjecturar para suas equações recorrentes, você não
terá aprendido a discernir se seus programas são ou não corretos,
e a provar isto.''

No próximo capítulo, você será introduzido aos
conceitos básicos sobre árvores e grafos, começando a desenvolver
a capacidade de modelar e implementar problemas reais usando tais
ferramentas e de estruturas de dados. Só assim você poderá
acompanhar algumas disciplinas posteriores e resolver muitos dos
problemas reais com que se deparará em sua futura profissão de
programador e analista.



////
Sempre termine os arquivos com uma linha em branco.
////
