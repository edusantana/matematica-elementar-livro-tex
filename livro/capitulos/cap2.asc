[[cap2]]
== Introdução à Lógica Matemática

*Lógica* é o estudo dos mecanismos de raciocínio (os que são válidos, e os que são falaciosos). *Lógica Matemática* é o estudo das inferências válidas dentro de uma linguagem _formal_ (em oposição a linguagem informal). Uma _linguagem formal_ é um conjunto de _símbolos_ e um conjunto de _regras_ para combiná-los.

*Nosso objetivo, nesta unidade,* é que, ao final dela, você domine as mais básicas noções e propriedades da parte mais fácil e básica da Lógica Matemática, que é a _Lógica Proposicional_, podendo verificar se suas fórmulas são sintaticamente bem formadas, sabendo corretamente derivar fórmulas a partir de outras, decidir se fórmulas são semanticamente verdadeiras ou falsas, se são satisfatíveis ou não, se são tautologias ou não, se inferências são válidas ou não, etc. Só assim você será capaz de, ainda nesta atual disciplina, vencer dois futuros capítulos (<<cap3>> e <<cap4>>), sobre métodos de prova de teoremas; e, no futuro, será capaz de acompanhar a disciplina _Agentes Inteligentes_ e, talvez, outras disciplinas complementares optativas. 

.Lembre:
[TIP]
====
Estamos torcendo por você. O fórum de alunos, os tutores, e eu (o professor) queremos e vamos ajudá-lo (nessa ordem), mas você tem que ser determinado e disciplinado, *cada semana dedicando 4 a 8 horas para estudar este livro*, entender e reter os exemplos, resolver sozinho pelo menos 1/3 dos exercícios propostos, sumariar em sua mente os principais pontos desta unidade.
====

.Conteúdo deste capítulo
____________________

* Motivação. Lógica. Porque só Veremos a Lógica Proposicional
* A Linguagem £ da Lógica Proposicional
* Regras de Inferência. Sistemas Formais. Sistema Natural de Inferência
* Sanidade, Completude, Consistência. Os Problemas da Satisfatibilidade e da Tautologia. Modelo e Teoria
____________________

[NOTE]
====
Se você quiser ver o assunto mais explicada e profundamente, não precisará de mais que os livros textos da ementa da disciplina. Outro bom livro é Introdução à Lógica para a Ciência da Computação (Abe, Scalzitti, Silva Filho).

Mas, para escrever esta unidade, além deles também usamos (mais como esqueleto mestre e plano geral e ordem de apresentação) partes do artigo A First Look at Propositional Logic, por Andreas Klappenecker, http://faculty.cs.tamu.edu/klappi/cpsc289-f08/propositional_logic.pdf. Alguns exemplos e problemas devem-se aos livros-texto, outros à Professora Joseluce de Farias Cunha, em http://www.dsc.ufcg.edu.br/~logica/, http://buscatextual.cnpq.br/buscatextual/visualizacv.do?metodo=apresentar&id=K4776902Y4; outros à Prof. Virgínia Maria Rodrigues, em http://www.pucrs.br/famat/demat/facin/estrualg.htm; outros, à Prof. Maria Helena Santos Marques http://www.estig.ipbeja.pt/~mhsm/mat_dis_informacoes.htm; outros, ao aluno http://www.danielclemente.com/logica/dn.en.html; e outras fontes que serão indicadas.

====

//_

=== Motivação. Lógica. Porque só Veremos a Lógica Proposicional

* *Lógica* é o estudo dos mecanismos de raciocínio (os que são válidos, e os que são falaciosos). 
* *Lógica Matemática* é o estudo das inferências válidas dentro de uma linguagem _formal_ (em oposição a linguagem informal), onde uma _linguagem formal_ é um conjunto de _símbolos_ e um conjunto de _regras_ para combiná-los. A Lógica Matemática pode ser dividida em lógicas clássicas e não clássicas. 
* *Lógicas Matemáticas Clássicas* são aquelas que compartilham das seguintes características básicas: 
** _Lei do terceiro excluído_ (cada proposição é verdadeira ou é falsa, não havendo nenhuma outra possibilidade entre ou além dessas duas) e _eliminação da dupla negação_ (uma negação de uma negação equivale a uma afirmação);
** _Lei da não contradição_ (declarações contraditórias não podem ambas ser verdadeiras no mesmo sentido e ao mesmo tempo), e o _princípio da explosão_ (se aceitássemos uma contradição como uma verdade, tudo poderia ser deduzido);
** _Monotonicidade de vinculação_ (uma proposição que teve um valor Verdade ou Falso a ela atribuído sempre o continuará a ter, e podemos livremente adicionar outras proposições como suposições suas companheiras, desde que não a contrariem) e _idempotência de vinculação_ (de muitas maneiras deduzir um mesmo valor Verdade ou Falso para uma declaração não tem nenhum valor a mais que deduzi-lo uma só vez);
** _Comutatividade da conjunção_ (a proposição ``A e B'' é o mesmo que a proposição ``B e A'');
** _Dualidade de De Morgan_: cada conectivo lógico é dual de outro (detalhes mais adiante).

Há muitas razões para você estudar Lógica Matemática (clássica), pois ela é a indispensável base para todas as provas de teoremas da Matemática, para você provar que um programa é correto, para você conceber e projetar circuitos lógicos, e muitas e importantes outras coisas. O estudo da Lógica Matemática é tão importante e fascinante que poderia ser uma disciplina em si. Seja como for, no curso de Licenciatura em Computação ela já é cerca de um quarto de uma das disciplinas complementares optativas do curso, a disciplina Agentes Inteligentes. Pela nossa exiguidade de tempo de estudo e de espaço nesta disciplina e livro, só poderemos estudar a primeira e mais fácil parte da Lógica Matemática, isto é, a Lógica Proposicional, que não tem variáveis. Em Agentes Inteligentes você procederá para a Lógica de 1ª Ordem. Dominar a Lógica Proposicional agora será muito necessário para você fazer o resto desta disciplina, e do curso, e depois, para certos aspectos de sua vida profissional.

* Uma *proposição* (ou *sentença*) é uma declaração que é verdadeira ou é falsa. Dois exemplos: ``João é honesto''; '``o sol é quadrado''. 
* *Lógica Proposicional* (ou *sentencial*) estuda como proposições verdadeiras podem ser combinadas por meio de conectivos para produzir outras afirmações verdadeiras. Um exemplo: Se supusermos que ambas as proposições 'o cão é branco' e 'o cão é manso' são verdadeiras, então podemos combiná-las na afirmação 'o cão é branco e o cão é manso' e podemos inferir que ela é verdadeira. No entanto, se constatarmos que a segunda afirmativa é falsa, então podemos concluir que a afirmativa combinada também é falsa. Lógica Proposicional nos permite _formalizar_ tais declarações e raciocínios, com a vantagem colateral de que ficarão mais concisos (e frequentemente removerão a ambiguidade da linguagem natural e as fraquezas do raciocínio natural): Podemos chamar de A a primeira proposição ('o cão é branco') e de B a segunda ('o cão é manso'), então a declaração combinada ``A e B'' se expressa na Lógica Proposicional na forma latexmath:[$A \wedge B$], onde latexmath:[$\wedge$] é um conectivo que formaliza a palavra 'e'.

=== A Linguagem latexmath:[$\pounds$] da Lógica Proposicional

A Lógica Proposicional tem uma linguagem artificial que chamaremos de latexmath:[$\pounds$] (``latexmath:[$\pounds$]'' é uma letra do alfabeto do latim antigo, usada como símbolo da unidade monetária romana, a libra. Os exigentes pronunciam ``latexmath:[$\pounds$]'' como ``libra'', os não exigentes como nossa letra l _``éle''_). Como toda linguagem, latexmath:[$\pounds$] tem uma _sintaxe_ e uma _semântica_. A _sintaxe_ de uma linguagem preocupa-se com sua forma: o vocabulário inicial e as regras de formação de ``expressões'' bem-formadas a partir dele. A _semântica_ está preocupada com o _significado_ destas expressões bem-formadas.

==== A Sintaxe de latexmath:[$\pounds$]

O *vocabulário* (inicial) de latexmath:[$\pounds$] é constituído dos seguintes símbolos:

[width="100%", cols="3<.^,1<.^,4<.^"]
|====
|*letras proposicionais* (ou *símbolos de proposições*)(em número infinito mas contável) 2+|latexmath:[$a, a_0, a_1, \ldots, b, b_0, b_1, \ldots, z, z_0, z_1, \ldots$]

.7+|*conectivos lógicos* |latexmath:[$\neg$] |ler *``não''*
|latexmath:[$\wedge$] |ler *``e''*
|latexmath:[$\oplus$] |ler *``ou excludente''*
|latexmath:[$\vee$] |ler *``ou''*
|latexmath:[$\rightarrow$] |ler *``implica''*, ou ``se'', ou ``se então'', ou ``implicação material'', ou ``condicional''
|latexmath:[$\leftrightarrow$] |ler *``se e somente se''*, ou ``equivale-a'', ou ``implica nos dois sentidos'', ou ``equivalência material'', ou ``bicondicional''
2+|Há quem acrescente outros conectivos: 

* *nor* (latexmath:[$\bar{\vee}$]) é a negação do latexmath[$\vee$]; 
* *nand* (latexmath[$\bar{\wedge}$]) é a negação do latexmath:[$\wedge$];
* *latexmath:[$a \leftarrow b$]* (``latexmath:[$a \mbox{ é implicado por } b$]'') é definido como equivalente a latexmath:[$b \rightarrow a$]; etc. 

Mas podemos viver sem eles, por isso vamos deixá-los de fora. Também poderíamos viver sem o latexmath:[$\oplus$], o latexmath:[$\rightarrow$] e o latexmath:[$\leftrightarrow$], mas os conservamos pela sua conveniência.

.2+|*sinais de pontuação |( |ler *``abre parênteses''
|) |ler *``fecha parênteses''
|====

Uma *fórmula* de latexmath:[$\pounds$] é toda sequência finita contendo símbolos somente do seu vocabulário.

.{zwsp}
====
São fórmulas:

[width="100%", cols="<,<,<", grid="none", frame="none"]
|====
|latexmath:[$)p_1$]
|latexmath:[$\wedge p_{20} \leftrightarrow )) p_{10000000}$]
|latexmath:[$(p_1 \wedge p_2 \vee \neg p_{67})$]
|====
====

.{zwsp}
====
Não são fórmulas:

[width="100%", cols="<", grid="none", frame="none"]
|====
|latexmath:[$\#_1$], porque não previmos latexmath:[$\#_1$] no vocabulário
|latexmath:[$\mbox{~} p_2$], porque ~ não pertence ao vocabulário de latexmath:[$\pounds$]
|latexmath:[$q_1 \& q_2$], porque latexmath:[$\&$] não pertence ao vocabulário de latexmath:[$\pounds$]
|====
====

Uma *fórmula bem formada* (*fbf*) de latexmath:[$\pounds$] é toda fórmula que satisfaz as seguintes condições:

* latexmath:[$V,F$] são fbf’s
* Toda letra proposicional é uma fórmula que também é uma fbf, isto é, latexmath:[$p_1, p_2, p_3, p_4,\ldots$] são fbf’s. 
* Se latexmath:[$\alpha$] for uma fbf, então latexmath:[$\neg \alpha$] será uma fbf. _(latexmath:[$\alpha$] é uma metavariável, isto é, não pertence à linguagem latexmath:[$\pounds$], é apenas um nome genérico, a ser instanciado para ser qualquer nome realmente pertencente a latexmath:[$\pounds$])_
* Se latexmath:[$\alpha \mbox{ e } \beta$] forem fbf’s, então latexmath:[$\alpha \wedge \beta$] será uma fbf.
* Se latexmath:[$\alpha \mbox{ e } \beta$] forem fbf’s, então latexmath:[$\alpha \oplus \beta$] será uma fbf.
* Se latexmath:[$\alpha \mbox{ e } \beta$] forem fbf’s, então latexmath:[$\alpha \vee \beta$] será uma fbf.
* Se latexmath:[$\alpha \mbox{ e } \beta$] forem fbf’s, então latexmath:[$(\alpha \leftarrow \beta )$]) será uma fbf.
* Se latexmath:[$\alpha \mbox{ e } \beta$] forem fbf’s, então latexmath:[$\alpha \leftrightarrow \beta$] será uma fbf.
* Se latexmath:[$\alpha$] for uma fbf, então latexmath:[$(\alpha)$] será uma fbf.
* Nada mais é fbf. 

Ambiguidades (quando as regras acima lhe deixarem em dúvida sobre que operação fazer primeiro, porque mais de uma delas pode ser aplicada) são resolvidas através da *ordem de precedência para os operadores* (que, de maior para menor, é latexmath:[$\neg , \wedge , \oplus , \vee , \rightarrow , \leftrightarrow$]) ou através de parênteses. Por exemplo, latexmath:[$\neg P \vee Q \wedge R \rightarrow S$] é equivalente a latexmath:[$((\neg P) \vee (Q \wedge R))\rightarrow S$] (primeiro são feitos todos os latexmath:[$\neg$] de 1º nível da fbf, depois todos os latexmath:[$\wedge$], depois todos os latexmath:[$\vee$], finalmente todos os latexmath:[$\rightarrow$]).

.{zwsp}
====
São fbf's:

[width="100%", cols="<,<,<,<", frame="none", grid="none"]
|====
|latexmath:[$p_123$]
|latexmath:[$(\neg p_1)$]
|latexmath:[$(p_1 \vee p_2 )$]
|latexmath:[$(p_2 \vee p_1 )$]
||||
|latexmath:[$(p_5 \rightarrow p_6 )$]
|latexmath:[$((p_1 \vee p_2 ) \leftrightarrow (p_3 \rightarrow p_4 ))$]
||
|====
====

.{zwsp}
====
São fórmulas não bem- formadas: 
[width="100%", cols="1<,3<", frame="none", grid="none"]
|====
|latexmath:[$p_1(8$] |falta um fecha parênteses, e 8 não é uma letra proposicional
|latexmath:[$\neg \; p_1$] |o problema é o espaço em branco entre latexmath:[$\neg \mbox{ e } p_1$]
|latexmath:[$p_1 \; \wedge \; p_3$] |o problema são os espaços em branco ao redor de latexmath:[$\wedge$]
|latexmath:[$(((\neg p_1) \vee p_1) \rightarrow p_3$] |os abre-parênteses e fecha-parênteses não casam
|latexmath:[$(((\neg p_1)\vee ))\rightarrow p_3$] |falta o 2º argumento do latexmath:[$\vee$]
|====
====

Somente quando você chegar à disciplina Teoria da Computação estudará o formalismo chamado de Forma de Backus- Naur (em inglês, BNF, abreviação de _Backus Naur Form_), usado para especificar a parte livre-de-contexto das linguagens de programação. Mas como ele é muito intuitivo, veja em BNF a mesma definição de fbf que foi escrita pouco acima:

[latexmath]
++++
\[\langle fbf \rangle ::= \neg\langle fbf \rangle \vert  \langle fbf \rangle \wedge \langle fbf \rangle \vert  \langle fbf \rangle \oplus \langle fbf \rangle \vert  \langle fbf \rangle \vee \langle fbf \rangle \vert  \langle fbf \rangle \rightarrow \langle fbf \rangle \vert  \langle fbf \rangle \leftrightarrow \langle fbf \rangle \vert (\langle fbf \rangle) \vert \langle SimboloDeProposicao \rangle \vert V \vert F\]
++++

<SímboloDeProposição> é qualquer outro símbolo terminal: qualquer letra minúscula, possivelmente com subscrito que seja um inteiro sem sinal. Isto é, um elemento do conjunto latexmath:[$S = \{a, a_0, a_1,\ldots, b, b_0, b_1,\ldots, z, z_0, z_1,\ldots\}$]. 

A precedência de operadores latexmath:[$\neg \; \wedge \; \oplus \; \vee \; \rightarrow \; \leftrightarrow$] será usada na escolha das regras BNF que puderem ser aplicadas a um mesmo estágio da avaliação da árvore sintática (ou de derivação ou de parsing). A associatividade, para cada conectivo binário, é escolhida ser da esquerda para a direita. Na disciplina Teoria da Computação (e na complementar optativa Introdução aos Compiladores) você verá os conceitos de árvore de derivação e entenderá melhor isto, bem como a detecção automatizada se uma fórmula é bem formada ou não.

É preferível uma BNF que seja inambígua sem recorrer a definições extra gramática da precedência e associatividade (esquerda para direita) de operadores:

[width="80%", cols="<", frame="none", grid="none"]
|====
|latexmath:[$\langle FBF \rangle  ::= \langle ExprSe \rangle  \vert  \langle FBF \rangle \leftrightarrow \langle ExprImplica \rangle $] 

latexmath:[$\langle ExprImplica \rangle  ::= \langle ExprOu \rangle  \vert  \langle ExprImplica \rangle \rightarrow\langle ExprOu \rangle $] 

latexmath:[$\langle ExprOu \rangle  ::= \langle ExprXor \rangle  \vert  \langle ExprOu \rangle \vee \langle ExprXor \rangle $] 

latexmath:[$\langle ExprXor \rangle  ::= \langle ExprE \rangle  \vert  \langle ExprXor \rangle \oplus \langle ExprE \rangle $] 

latexmath:[$\langle ExprE \rangle  ::= \langle FormAtomica \rangle  \vert  \langle ExprE \rangle \wedge \langle FormAtomica \rangle $] 

latexmath:[$\langle FormAtomica \rangle  ::= V \vert  F \vert  \langle  SímboloDeProposição  \rangle  \vert  \neg \langle FormAtomica \rangle  \vert  (\langle fbf \rangle )$] 

latexmath:[$\langle$]SímboloDeProposição latexmath:[$\rangle ::= $] qualquer outro símbolo terminal: qualquer letra minúscula, possivelmente com subscrito que seja um inteiro sem sinal. Isto é, um elemento do conjunto latexmath:[$S = \{a, a_0, a_1, \ldots, b, b_0, b_1, \ldots, z, z_0, z_1,\ldots\} $]
|====

.(PUCRS, Virgínia Maria Rodrigues, em http://www.pucrs.br/famat/demat/facin/estrualg.htm)
====
Sejam as proposições: latexmath:[$p: \mbox{ Gosto de viajar e } q: \mbox { Visitei o Chile}$]. Escreva as sentenças verbais que estão representadas pelas proposições abaixo:


*Soluções:*

[width="100%", cols="<,<,<,<", frame="none", grid="none"]
|====
|a) latexmath:[$p \leftrightarrow q$] |b) latexmath:[$\neg q \rightarrow \neg p$] |c) latexmath:[$(p \wedge \neg q) \rightarrow \neg p\$] |d) latexmath:[$q \wedge \neg p$]
||||
|e) latexmath:[$\neg (p \wedge q)$] |f) latexmath:[$q \rightarrow p$] |g) latexmath:[$\neg p \vee \neg q$] |h) latexmath:[$(p \vee \neg q) \wedge (\neg p \rightarrow q)$]
|====

====

