[[cap7]]
== Novo capítulo

[NOTE]
====
Perguntas para despertar e aguçar sua curiosidade e interesse:

. Há algum inteiro latexmath:[$n>2$] tal que latexmath:[$a^n + b^n = c^n$], onde latexmath:[$a, b, c$] são naturais? Faça umas tentativas. 
. Ao usarmos o Crivo de Erastóstenes, a cada vez mais naturais cortados vão ficando vizinhos em sequências enormes, e os primos ficando mais extremamente raros e espaçados. Você acha que existe um natural a partir do qual não há mais nenhum primo maior que ele (todos os naturais maiores que eles formam uma sequência de vizinhos crivados), de modo que o número de primos é finito? Por que sim ou por que não? 
. Você acha que determinar, com absoluta certeza, se um natural de 1000 dígitos é primo leva quanto tempo no mais rápido computador da loja da esquina? Horas? Anos? Milênios?
. Você sabe uma maneira eficiente de calcular latexmath[$a^b \mod{m}$] (todas as variáveis sendo naturais), quando a representação decimal de latexmath[$a$] pode ter até 10.000 dígitos, latexmath[$b$] até 8 dígitos, latexmath[$m$] até 4 dígitos?
====

*Nosso objetivo, neste capítulo*, é que, ao final dela, você domine as mais básicas noções e propriedades dos números inteiros, podendo responder às questões acima e outras, particularmente sabendo: como testar se um inteiro é primo ou não; de forma muito eficiente achar o máximo divisor comum (e o mínimo múltiplo comum) e onde podem ser usados em outros problemas; aritmética modular e congruências.

.Sempre vamos repetir
[TIP]
====
Estamos torcendo por você. O fórum de alunos, os tutores, e eu (o professor) queremos e vamos ajudá-lo (nessa ordem), mas você tem que ser determinado e disciplinado, *cada semana dedicando 4 a 8 horas para estudar este livro*.
====

.Conteúdo deste capítulo
____________________
* Definição: A Teoria dos Números
* Números Primos
** Testando Primalidade de n
** Contando os Primos
** Mais Algumas Poucas Coisas Sobre os Primos
* Divisibilidade
** Máximo Divisor Comum (mdc) (Greatest Common Divisor. gcd)
** Mínimo Múltiplo Comum (mmc) (Least Common Multiple. lcm)
* Aritmética Modular
** Problema 374 do ACM Programming Contest (BigMod)
* Congruências
** Operações Sobre Congruências
** Resolvendo Congruências Lineares
** Equações Diofantinas
* Triplas Pitagóricas
____________________

[NOTE]
====
Embora os conteúdos tenham sido aprofundados usando outras fontes, os tópicos foram ``pinçados'' a partir do Cap. 7 ``_Number Theory_'' do livro ``_Programming Challenges_'' de _Steven S. Skiena_ e _Miguel A. Revilla_ (download gratuito de http://acm.cs.buap.mx/downloads/Programming_Challenges.pdf). Portanto, provavelmente só cobrimos os cerca de 30% mais fáceis da Teoria dos Números, mas que têm mais aplicação prática nas competições de programação. Uma referência mais abrangente e profunda é http://mathworld.wolfram.com/topics/NumberTheory.html, com centenas de artigos em dezenas de assuntos. Mas qualquer dos livros textos da disciplina cobre todas as suas 7 unidades.
====

//_

=== Definição: A Teoria dos Números

Ou, simplesmente, ``aritmética'', ou ``aritmética superior'' é o ramo da Matemática Pura que estuda propriedades dos números em geral e, em particular, dos números inteiros, bem como a larga classe de problemas que surge no seu estudo. Mesmo sendo da Matemática Pura, a Teoria dos Números tem uma extraordinária importância prática, sendo a base para toda a área de criptografia moderna (que possibilita segurança no trânsito de informações vitais pela internet), sendo também a base para se conceber alguns algoritmos aceitavelmente eficientes ao invés de impraticavelmente lentos.

Exemplo de um dos mais famosos resultados da Teoria dos Números: 

.O Último Teorema de Fermat:
====
Não existe nenhum conjunto de inteiros positivos latexmath:[$a, b, c, n$], com latexmath:[$n > 2$], que satisfaça.

[latexmath]
++++
\[a^n + b^n = c^n\]
++++

A prova deste teorema, enunciado por Fermat em cerca de 1637, é tão difícil que somente foi achada por Wiles em 1995. E é muito longa e difícil para a discutirmos aqui. http://en.wikipedia.org/wiki/Fermat\'s_Last_Theorem#Wiles.27s_general_proof conta a história da evolução da prova ao longo dos séculos.
====

=== Números Primos

*Número primo* é qualquer natural latexmath:[$p \geq 2$] que somente seja divisível por si mesmo e por 1. Por exemplo: 7 é primo (porque só é divisível por si mesmo e por 1).

*Número composto* é qualquer natural latexmath:[$q \geq 2$] que não seja primo. (Isto é, além de divisível por 1 e por ele mesmo, é divisível pelo menos por algum outro natural.) Por exemplo: 6 é composto (isto é, não primo) (porque, além de divisível por si mesmo e por 1, o é por outros naturais: 2 e 3).

*Teorema Fundamental da Aritmética* ( http://pt.wikipedia.org/wiki/Teorema_fundamental_da_aritm%C3%A9tica ):

//_

Todos os números inteiros positivos maiores que 1 podem ser decompostos num produto de números primos, sendo esta decomposição única a menos de permutações dos fatores. (Este teorema foi exposto, pela primeira vez, no livro _IX dos Elementos_, de Euclides (13 volumes, escritos no ano de cerca de 300 aC). Mais formalmente:

[quote]
Seja latexmath:[$a>1$] um inteiro positivo. Então, existem primos positivos latexmath:[$p_1 \leq p_2 \leq \ldots \leq p_t$] tais que latexmath:[$a = p_1 p_2 \ldots p_t$], e essa decomposição é única.
 
(chamamos latexmath:[$p_1, \ldots , p_t$] de fatores primos de latexmath:[$a$]. Ao processo de encontrá-los, chamamos de fatoração (de latexmath:[$a$]) em primos) (Na fatoração de um número em primos poderá ser de utilidade a tabela dos primeiros 10000 números primos, em http://primes.utm.edu/lists/small/10000.txt )

*Demonstração:*

Existência de uma Decomposição:: +
Será usado para esta demonstração o _Princípio da Indução Completa_ (releia <<cap3>>). +
Para latexmath:[$a=2$] existe apenas a decomposição trivial em números primos latexmath:[$1 \times 2$], já que 2 é primo. Suponhamos agora 
que existe uma tal decomposição para todo inteiro latexmath:[$b$], latexmath:[$2 \leq b < a$]. Mostraremos que também existe para latexmath:[$a$]. +
Se latexmath:[$a$] é primo, admite somente a decomposição trivial latexmath:[$a = 1 \times a$]. +
Caso contrário, admite um divisor positivo latexmath:[$b$] tal que latexmath:[$1<b<a$]. Isto é, latexmath:[$a=bc$], e temos também latexmath:[$1<c<a$]. +
Pela hipótese indutiva, latexmath:[$b$] e latexmath:[$c$] podem ser escritos como produtos de primos, na forma latexmath:[$m= = p_1bp_2 \ldots p_s$], latexmath:[$c = = q_1 q_2 \ldots q_k$]. Substituindo, temos latexmath:[$a=p_1 \ldots p_s q_1 \ldots q_k$], e a referida decomposição também existe para latexmath:[$a$].

Unicidade da Decomposição:: 
Dado um inteiro latexmath:[$a$], ele poderia admitir, em princípio, mais de uma decomposição em produto de fatores primos. Chamemos de 
_comprimento de uma decomposição_ o número de fatores que nela comparecem. +
A demonstração será feita por indução no comprimento de uma decomposição de latexmath:[$a$]. +
Suponhamos que a admita uma decomposição do tipo latexmath:[$a = p_1$], onde latexmath:[$p_1$] é primo, e que vale latexmath:[$a = p_1 = q_1 q_2 \ldots q_s$] em que latexmath:[$q_1 \leq q_2 \leq \ldots \leq q_s$] são primos positivos. +
Como latexmath:[$q_1$] divide latexmath:[$q_1 q_2 \ldots q_s$], então latexmath:[$q_1$] também divide latexmath:[$p_1$], que é primo. Então,
 devemos ter latexmath:[$p_1 = q_1$]. Cancelando, vem latexmath:[$1 = q_2 \cdots q_s$]. Se latexmath:[$s > 1$], teríamos que o primo 
 latexmath:[$q_2$] seria inversível, uma contradição. Assim, latexmath:[$s = 1$] e, como já provamos que latexmath:[$p_1 = q_1$], o primeiro
 passo da indução está verificado. +
Suponhamos agora o resultado verdadeiro para todo inteiro que admita uma decomposição de comprimento latexmath:[$k \geq 1$], e seja a um inteiro com uma decomposição de comprimento latexmath:[$k+1$]. Se este inteiro a admitisse outra decomposição, teríamos latexmath:[$a = p_1 \cdots p_{k+1} = q_1 \cdots q_s$], em que latexmath:[$q_1 \leq q_2 \leq \cdots \leq q_s$] são primos positivos. +
Como, na primeira parte, latexmath:[$q_1$] divide latexmath:[$p_1 \cdots p_{k+1}$], consequentemente temos que latexmath:[$q_1$] divide 
latexmath:[$p_i$] para algum latexmath:[$i$] (Lema de Euclides). Como latexmath:[$p_i$] é primo, devemos ter novamente que latexmath:[$q_1 = p_i$]. Em particular, latexmath:[$q_1 \geq p_1$]. +
De forma análoga, pode-se obter que latexmath:[$p_1 = q_j$], para algum latexmath:[$j$]. Logo, latexmath:[$p_1 \geq q_1$]. De ambas as
 desigualdades, vem que latexmath:[$p_1 = q_1$]. Finalmente, cancelando em latexmath:[$a = p_1 \cdots p_{k+1} = q_1 \cdots q_s$], temos que
 latexmath:[$p_2 \cdots p_{k+1} = q_2 \cdots q_s$]. +
Agora, o primeiro membro da igualdade tem uma decomposição de comprimento latexmath:[$k$], logo, da hipótese de indução, admite uma única
 decomposição. Assim, temos latexmath:[$k = s-1$], donde latexmath:[$k+1=s$] e latexmath:[$p_i = q_i$], para latexmath:[$i=2,\ldots ,k+1$].
 Como já provamos que latexmath:[$p_1 = q_1$], ambas as expressões de latexmath:[$a$] coincidem.

Colorário:: Se um número primo divide o produto de dois números inteiros, então ele é divisor de um dos dois.

*Teorema de Euclides (de cerca do ano 300 aC!): há um número infinito de primos.*

Prova:: 
Suponhamos que o número de primos é finito e igual ao natural latexmath:[$r$]. Chamemos o maior deles de latexmath:[$p_r$]. Ordenemos e
 demos nomes a todos os primos, assim: latexmath:[$p_1=2 < p_2 = 3 < \cdots < p_r$]. Seja latexmath:[$P = (p_1 p_2  \cdots p_r) + 1$].
 Evidentemente latexmath:[$P$] é maior que cada um dos números primos. Temos duas possibilidades e veremos que ambas levam a uma contradição: +
 Caso latexmath:[$P$] seja primo, então, por ser maior que cada latexmath:[$p_1, \ldots, p_r$], é um novo primo (diferente de 
 latexmath:[$p_1, \ldots, p_r$]), o que contradiz nossa suposição. +
 E, caso latexmath:[$P$] seja não primo, então  latexmath:[$P = (p_1 p_2 \cdots p_r) + 1$] não é fatorável por nenhum dos primos 
 latexmath:[$p_1, \ldots , p_r$]). Portanto, latexmath:[$P $] tem que ser um novo primo (diferente de latexmath:[$p_1, \ldots, p_r$]), o que
 contradiz nossa suposição. +
Como as 2 hipóteses possíveis levaram a contradições da suposição, esta tem que ser falsa, impossível. Portanto, o número de primos é 
infinito. C.Q.D.

.Explicação adicional:
NOTE: caso latexmath:[$P$] seja não primo, tem que ser fatorável por primos (menores que ele mesmo), e chamemos de latexmath:[$p$] um dos
 primos (há pelo menos um deles) que divida latexmath:[$P$]; então, latexmath:[$p$] não pode ser igual ao primo latexmath:[$p_1 = 2$] porque
 o primeiro múltiplo de latexmath:[$p_1$] maior ou igual a latexmath:[$P$] é latexmath:[$(P-1)+p_1$]; idem para o primo latexmath:[$p_2=3$];
 e para o primo latexmath:[$p_3 = 5$]; ...; e para o primo latexmath:[$p_r$]. Isto é, latexmath:[$P = (p_1 p_2 \cdots p_r) + 1$] não é fatorável por nenhum dos primos latexmath:[$p_1, \ldots, p_r$].

IMPORTANT: É um erro comum pensar que esta prova diz que o natural latexmath:[$P = p_1p_2 \cdots p_r +1$] é primo. (Um contra-exemplo é latexmath:[$P = 2 \times 3 \times5 \times 7 \times 11 \times 13 + 1   =  30031$], que é divisível por 59. Desafio-o, para lhes ajudar a entender melhor, que encontre outro contra-exemplo, com latexmath:[$P$] menor). Na verdade, a prova somente usa o fato que, se latexmath:[$P$] não for um primo novo (diferente de latexmath:[$p_1, p_2, \ldots, p_r$]), então há um primo novo que divide latexmath:[$P$].

==== Testeando Primalidade de latexmath:[$n$]

*Primeira abordagem exata* simples- direta- ineficiente: teste se latexmath:[$n$] é divisível por cada um dos naturais 2,3,4,5,6, até latexmath:[$\sqrt{n}$](arredondado para baixo).  No pior caso, o número de divisões é assintoticamente proporcional a latexmath:[$\sqrt{n}$], isto é, é latexmath:[$O(\sqrt{n})$].

*Segunda abordagem exata*: ainda simples- direto- ineficiente: tente dividir por 2, depois por todos os ímpares 3,5,7,9,11,13,15, até latexmath:[$\sqrt{2}$] (arredondado para baixo). No pior caso, o número de divisões ainda é assintoticamente proporcional a latexmath:[$\sqrt{n}$], isto é, é latexmath:[$O(\sqrt{n})$]. Mas é 2 vezes mais eficiente que acima. Eis o programa:

----
prime_factorization(long x)
{
  long i; /* counter */
  long c; /* remaining product to factor */
  c = x;
  while ((c % 2) == 0) {
    printf("%ld\n",2);
    c = c / 2;
  }
  i = 3;
  while (i≤(sqrt(c)+1)) {
    if ((c % i) == 0) {
      printf("%ld\n",i);
      c = c / i;
      }
    else
      i = i + 2;
  }
  if (c > 1) printf("%ld\n",c);
}
----

//_

*Terceira abordagem exata*: Observe que todos os primos são de forma latexmath:[$6k \pm 1$], com 2 e 3 sendo as únicas exceções. Isto 
decorre do fato que todos os inteiros podem ser expressos como (latexmath:[$6k + i$]) para algum inteiro latexmath:[$k$] e para 
latexmath:[$i = -1, 0, 1, 2, 3, \mbox{ ou } 4$]; note que 2 divide latexmath:[$(6k + 0), (6k + 2), (6k + 4)$]; e 3 divide latexmath:[$(6k + 3)$]. Portanto, um método mais eficiente é testar se latexmath:[$n$] é divisível por 2, depois testar se é divisível por 3, então checar 
através de todos os números da forma latexmath:[$6k \pm 1$], até isto ultrapassar latexmath:[$\sqrt{n}$](arredondado para baixo). Isto é,
 checar para latexmath:[$n = 2,3,5,7,11,13,17,19,23,29,31,37,\ldots$]. No pior caso, o número de divisões ainda é assintoticamente 
 proporcional a latexmath:[$\sqrt{n}$], isto é, é latexmath:[$O(\sqrt{n}$]). Mas é 3 vezes mais eficiente que a 2ª abordagem, 6 vezes mais 
 que a 1ª.
 
Outro *teste exato de primalidade*, ainda simples-direto-ineficiente: Sabe-se que, com exceção dos números 2 e 3, todos os outros números 
primos são expressos pela fórmula latexmath:[$6K \pm 1$]. Mas sabe-se que a imensa maioria dos números expresso pela fórmula 
latexmath:[$6K \pm 1$] não é constituida de números  primos (a relação é necessária, mas não suficiente). O estudo dos não-primos da forma
 latexmath:[$6K \pm 1$] leva à igualdade latexmath:[$K=6 k_2 k_3 \pm k_2 \pm k_3$].{#}(ver <<sec-7-5-3>>). 

Então: dado um número inteiro positivo qualquer latexmath:[$K$]: 

* Se não ocorrer nenhum par de números inteiros positivos latexmath:[$k_2,k_3$] {soluções de #} que satisfaça a igualdade acima, afirma-se
 que os números latexmath:[$6K \pm 1$] são números primos gêmeos (números primos que diferem um do outro de apenas duas unidades). Ex: 
 latexmath:[${29,31}$]. latexmath:[$K=5$]; nenhum latexmath:[$k_2,k_3$] positivos satisfazem {#}, portanto latexmath:[${29, 31}$] são primos
 gêmeos.
* Se não ocorrer nenhum par latexmath:[$k_2,k_3$] {soluções de #} com sinais iguais e ocorrer ao menos um par latexmath:[$k_2,k_3$] com 
sinais diferentes que satisfaça a equação, afirma-se que latexmath:[$6K+1$] é primo e latexmath:[$6K-1$] não é primo. 
* Se não ocorrer nenhum par latexmath:[$k_2,k_3$] {soluções de #} com sinais diferentes e ocorrer ao menos um par latexmath:[$k_2,k_3$] com 
sinais iguais que satisfaça a equação, afirma-se que latexmath:[$6K-1$] é primo e latexmath:[$6K+1$] não é primo. Ex: latexmath:[${23,25}$].
 latexmath:[$K=4$]; onde latexmath:[$k_2,= -1$] , latexmath:[$k_3 = -1$], latexmath:[$6 k_2 k_3 + k_2 + k_3 = 6-1-1= 4$]. Portanto 
 latexmath:[$6K \pm 1 = {23,25}$].

.Algoritmo (exato) AKS para Teste de Primalidade:
[NOTE]
====
Não vou exigir que você saiba mais que a existência e grande vantagem dele, mas veja em livros, artigos ou Internet o algoritmo (exato) AKS 
para testar primalidade, e que ele cai na classe latexmath:[$P$] (polinomial, em máquina determinística). É provado que, no pior caso, seu 
tempo de execução é assintoticamente proporcional a latexmath:[$\log^{(12+ \varepsilon)}{n}$], isto é, é latexmath:[$O(\log^{(12+ \varepsilon)}{n}$], onde latexmath:[$\varepsilon$] é um número pequeno. Em outras palavras, o algoritmo leva menos que uma constante vezes a
 12ª potência (mais latexmath:[$\varepsilon$]) do número de dígitos de latexmath:[$n$]. Ainda não foi provado, mas a experiência prática 
 sempre tem resultado em tempos de execução na ordem de uma constante vezes a 6ª potência (mais latexmath:[$\varepsilon$]) do número de
 dígitos de latexmath:[$n$].
====

*Teste* (com altíssima probabilidade, mas não exatidão) *de primalidade de Fermat* (adaptado de http://pt.wikipedia.org/wiki/Teste_de_primalidade_de_Fermat ): O Pequeno Teorema de Fermat, que originou o Teste de Primalidade de Fermat, 
oferece um teste simples e eficiente para ignorar números não primos. Qualquer número que falhe o teste não é primo.

*Pequeno Teorema de Fermat:*

[quote]
Se latexmath:[$m$] é primo, então para qualquer latexmath:[$a$] tal que latexmath:[$mdc(a,m) = 1$], temos: latexmath:[$a^{m-1} \equiv 1 (\mod{m})$] (notação explicada não muito longe, abaixo. Entenda assim: ``em aritmética módulo latexmath:[$m$], latexmath:[$a^{m-1}$] é congruente com 1'')

.Atenção:
IMPORTANT: Se latexmath:[$m$] não é primo, ainda é possível (embora pouco provável) que o supradito se verifique. Se latexmath:[$m$] é ímpar
 composto, e latexmath:[$a$] é um inteiro tal que latexmath:[$mdc(a,m) = 1$], e latexmath:[$a$] passa no teste de primalidade de Fermat (
isto é, latexmath:[$a^{m-1} \equiv 1(\mod{m})$] ), então se diz que ``latexmath:[$m$] é pseudoprimo para a base latexmath:[$a$]''. Isto 
equivale a se dizer ``latexmath:[$a$] é um número não primo que passa o teste de Fermat''.

Prova:: 
Seja latexmath:[$mdc(a,m) = 1$], consideremos os conjuntos latexmath:[$\{1,2,3, \ldots , m-1\}$] e latexmath:[$\{a, 2a, 3a, ..., (m-1)a\}$] e percebamos que cada número em latexmath:[$\{a, 2a, 3a, \ldots , (m-1)a\}$] é não congruente com 0 (tudo isto latexmath:[$\mod{m}$]) (i.é, nenhum desses novos números é múltiplo de latexmath:[$m$]). +
Sejam latexmath:[$i, j \in \{1,2,3, \ldots , m-1\}$]  e latexmath:[$i \cdot a \equiv j \cdot a (\mod{m})$], vemos que latexmath:[$i \equiv j (\mod{m})$], porque latexmath:[$mdc(a,m) = 1$], com isso, deduzimos que latexmath:[$i = j$], porque latexmath:[$0 \leq (i-j) < m$],
então, os números em latexmath:[$\{a, 2a, 3a, \ldots , (m-1)a\}$] são não congruentes com 0 (tudo latexmath:[$\mod{m}$]) e também são não congruentes entre si (tudo latexmath:[$\mod{m}$]). +
Então os números em latexmath:[$\{a, 2a, 3a, ..., (m-1)a\}$] são congruentes, em alguma ordem, com os números latexmath:[$\{1,2,3, ..., (m-1)\}$], tudo isto latexmath:[$\mod{m}$]. +
Conclui-se que: latexmath:[$(m-1)! = 1 \cdot 2 \cdot 3 \cdot 4 \cdot \cdots \cdot  (m-1) \equiv a \cdot 2a \cdot 3a \cdot 4a \cdot \cdots \cdot (m-1)a$], que implica que latexmath:[$(m-1)! \equiv a(m-1) \cdot (m-1)! \cdot (\mod{m})$]. +
Ora, já que latexmath:[$mdc(m,(m-1)!) = 1$], podemos cancelar o fator latexmath:[$(m-1)!$], e obtemos: latexmath:[$a^{m-1} \equiv 1 (\mod{m})$] o que conclui a prova.

NOTE: Infelizmente, existem números que passam o teste de Fermat para todas as bases para as quais são relativamente primos – são os 
chamados números de Carmichael, e são em número infinito (Tome conhecimento do problema http://icpcres.ecs.baylor.edu/onlinejudge/external/100/10006.html) .

*Teste (Forte) de (Pseudo) Primalidade, de Miller-Rabin  (muito bom) (detalhes em http://www.cin.ufpe.br/~tg/2009-2/abc.pdf, que descreve e avalia todos os mais importantes testes de primalidade existentes em 2009. O AKS é o melhor teste exato, mas é muito custoso, por isso, na prática, todos usam mais testes probabilísticos, particularmente os de Miller-Rabin e seus aperfeiçoamentos):

*Algoritmo Miller-Rabin (versão base, inicial. Depois foi modificado)*:

Dado latexmath:[$m$] +
Escreva latexmath:[$m-1 = 2^8 t$], em que latexmath:[$t$] é ímpar +
Escolha aleatoriamente latexmath:[$a \in [1,m[$] +
Calcule latexmath:[$h = a^t (\mod{m})$] +
Se latexmath:[$h = \pm 1$], então latexmath:[$m$] passa o teste +
Calcule latexmath:[$h^i = a^{(2^i)t}$]  para latexmath:[$i = 1,2,\ldots ,8$] +
Se latexmath:[$h^i = -1$] para algum latexmath:[$i < 8$], então latexmath:[$m$] passa o teste +
Caso contrário latexmath:[$m$] falha o teste.

NOTE: O teste deve ser repetido para latexmath:[$r$] bases diferentes. A probabilidade de um número composto latexmath:[$m$] passar latexmath:[$r$] testes é de 1 em latexmath:[$4^r$]. Se latexmath:[$m$] passar o teste para 100 bases diferentes, então a probabilidade de latexmath:[$m$] ser um número composto é menor que latexmath:[$10^{−60}$]. Código Pyton em http://www.dzone.com/snippets/miller-rabin-primality-test 

==== Contando os Primos

Não somente há um infinito número de primos, como os primos são relativamente comuns:

*Teorema dos Números Primos* (Gauss, aos 15 anos (!) ):

latexmath:[$\prod(n)$], o número de primos menores que ou iguais a latexmath:[$x$], é grosseiramente aproximado por latexmath:[$\frac{x}{\ln{x}}$]. http://mathworld.wolfram.com/PrimeNumberTheorem.html . Lembre que latexmath:[$\ln{x} \approx 2,303 \log_{10}{x}$], portanto o número de primos no intervalo latexmath:[$[2,x\]$] é aproximadamente latexmath:[$\frac{x}{(2,303 \log_{10}{x})} = \frac{0,4342x}{(\log_{10}{x})}$].

==== Mais Algumas Poucas Coisas Sobre os Primos

*``Conjectura forte de Goldbach'' (1742):* Sempre se pode exprimir os números pares, maiores que 2, como a soma de dois números primos.

*``Conjectura fraca de Goldbach'' (de 1742 e 1746):* Sempre se pode exprimir os números ímpares, maiores que 5, como a soma de três números
 primos. (obviamente, a conjectura forte implica a fraca: para representar um número ímpar como uma soma de três números primos é suficiente
 subtrair 3 dele e aplicar a versão forte para o número par resultante.) (267 anos depois, em 2013, o peruano Harald Andrés Helfgott, do 
 Centro Nacional para a Pesquisa Científica, na França, finalmente provou esta conjectura, que antes somente tinha sido testada até números 
 da ordem de latexmath:[$4 \times 10^{14}$]).

Outra conjectura (verificada, mas não provada): *os primos estão uniformemente distribuídos quanto seus últimos algarismos*. Isto é, dos 
infinitos primos, latexmath:[$1/4$] termina com o algarismo 1, latexmath:[$1/4$] com o 3, latexmath:[$1/4$] com o 7, latexmath:[$1/4$] com o
 9.

*Conjectura de Polignac (1849):* Há infinitos *pares* de números denominados primos gêmeos: números primos que diferem um do outro de apenas duas unidades, como latexmath:[$(3; 5), (71; 73) \mbox{ ou } (1000000007; 1000000009)$] (164 anos depois, em 2013, Yitang Zhang provou esta conjectura).

Outra conjectura: *Há infinitos pares de primos sexy* (do Latim _sex_, significando 6), isto é, que diferem por 6 um do outro: latexmath:[$(5,11), (7,13), (11,17), (13,19), (17,23), (23,29), (31,37), (37,43), etc$]. O maior que já foi descoberto (em 2009) tem 11593 dígitos. Os 
primos são latexmath:[$(p, p+6)$] e latexmath:[$p = (117924851 \times 587502 \times 9001\# \times (587502 \times 9001\# + 1) + 210) \times (587502 \times 9001\# - 1)/35 + 5$], onde latexmath:[$9001\#$] é um é um primorial, isto é, o produto de primos menores ou iguais a 9001, 
i.e., latexmath:[$9001\# = 2 \times 3 \times 5 \times \cdots \times 9001$].

* *Há infinitas triplas latexmath:[$\{p, p+6, p+12\}$] de primos sexy, onde latexmath:[$(p-6)$] e latexmath:[$(p+18)$] não são primos.*

* *Há infinitas quádruplas de primos sexy.*

* *Há somente 1 quíntupla de primos sexy: latexmath:[$5,11,17,23,29$].* Em qualquer outra quíntupla latexmath:[$\{p, p+6, p+12, p+18, p+24, p+30\}$] (onde latexmath:[$p>5$]), para todos os pares serem relativamente primos, um dos números tem que ser divisível por 5 (se um terminar em 1, o seguinte terminará com 7, o próximo com 3, o próximo com 9, o próximo com 5) e não será primo.

Quando arranjamos os naturais em uma espiral (chamada de _Espiral de Ulam_) e destacamos os números primos, observamos um intrigante e não 
totalmente explicado padrão, com os primos se alinhando num surpreendente padrão de segmentos de retas, em diagonal. Veja em 
http://mathworld.wolfram.com/PrimeSpiral.html e em http://en.wikipedia.org/wiki/Ulam_spiral e leia as conjecturas lá citadas

//_

Até 23.8.2008, o maior número primo encontrado é latexmath:[$2^{43112609}-1$], um número com 12.978.189 dígitos, descoberto pelo projeto 
GIMPS (_The Great Internet Mersenne Prime Search_), que é um projeto de computação distribuída pela Internet que usa o tempo ocioso de 
computadores pessoais, na procura por números primos específicos, os chamados *primos de Mersenne*. Um primo de Mersenne é um número primo
 do tipo latexmath:[$M_n = 2^n - 1$], onde latexmath:[$n$] é um natural. Atualmente, só descobrimos 45 deles: latexmath:[$3, 7, 31, 127, \ldots$].


*Crivo De Eratóstenes* (que você conhece desde o ensino fundamental): Solução Recursiva com Memoization:

 int sieve_memo[…]; 
 int sieve(int n) 
 { int i, j, c = 1; 
   for(i = 3; i≤n; i+=2) 
   { sieve_memo[i] = 1; 
     sieve_memo[i - 1] = 0; 
   } 
   sieve_memo[2] = 1; 
   for( i = 3; i≤n; i+=2) 
     if(sieve_memo[i] == 1) 
     { c++; 
       for(j = i + i; j≤n; j+=i) 
         sieve_memo[j] = 0; 
     } 
   return c; 
 }

.Em 1995
[NOTE]
====
Um estudante na École Polytechnique relatou que havia ``quebrado'' uma mensagem de desafio criptografada publicada na Web pela 
Netscape. A mensagem, uma transação eletrônica, tinha sido criptografada usando um algoritmo com uma variável (chave) de encriptação de 40 
bits. O que o aluno fez foi particionar o espaço da variável (chave) de encriptação (latexmath:[$2^{40} \approx 10{12} =$] 1 trilhão de 
chaves possíveis) através de um número de computadores aos quais lhe foi dado acesso, e colocá-los procurando a chave correta. Em outras 
palavras, ele executou um ataque de força bruta, teve sucesso, e achou a variável (chave) de encriptação usada na mensagem. Seu ataque durou
 cerca de 6 dias e processou cerca de 800.000 chaves por segundo (portanto, experimentou cerca de 417 bilhões de chaves possíveis). Enquanto
 a maioria dos analistas não acreditava que uma variável (chave) de encriptação de 40 bits estava imune a um ataque de força bruta, o 
 sucesso do aluno causou uma grande celeuma na imprensa. Além disso, o estudante postou seu programa em um site para que qualquer um pudesse
 copiar o programa e executar o ataque. Veja os atuais desafios e prêmios em aberto, em http://en.wikipedia.org/wiki/RSA_Factoring_Challenge .
====

NOTE: Na RSA footnote:[RSA é um algoritmo de criptografia de dados, que deve o seu nome a três professores do MIT (Massachusetts Institute
 of Technology), fundadores da atual empresa RSA Data Security, Inc., Ronald Rivest, Adi Shamir e Leonard Adleman, que inventaram este 
algoritmo — até a data (2008), a mais bem sucedida implementação de sistemas de chaves assimétricas, e fundamenta-se em teorias clássicas 
dos números. É considerado dos mais seguros, ... . Foi também o primeiro algoritmo a possibilitar criptografia e assinatura digital, e uma 
das grandes inovações em criptografia de chave pública.] Data Security Conference, Janeiro de 1997, foi anunciado que um estudante de 
Berkeley, usando o tempo ocioso de uma rede de 250 computadores, foi capaz de quebrar a mensagem criptografada de desafio da RSA, que usava 
uma chave de 40 bits, em (apenas) 3 horas e meia.

.Em 1997
[NOTE]
====
Um ataque de força bruta foi completado contra uma mensagem (desafio] na página web do DES (Data Encryption Standard). Citamos (parte
 de) o comunicado de imprensa da equipe do Desafio DES (encontrado na www.frii.com/~rtv/despr4.htm): LOVELAND, COLORADO (18 de junho de 1997
 ). Dezenas de milhares de computadores, através de todo os EUA e Canadá, ligaram-se entre si através da Internet, em um sem precedentes 
 esforço de supercomputação cooperativa para decifrar uma mensagem codificada com o Data Encryption Standard (DES), endossado pelo governo 
 (dos EUA). Respondendo a um desafio, incluindo um prêmio de 10.000 dólares, oferecidos pela RSA Data Security, Inc., o esforço DESCHALL 
 obteve êxito em decodificar a mensagem secreta da RSA. De acordo com Rocke Verser, um programador contratado (por outra empresa, claro) e 
 consultor, que desenvolveu o software especializado em seu tempo livre, ``Dezenas de milhares de computadores trabalharam cooperativamente 
 para vencer o desafio''. É melhor você ver em http://gilchrist.ca/jeff/distrib-des.html
====

.{zwsp}
====
Em termos aproximados, quantos primos há com o máximo de 500 dígitos? E com o máximo de 501 dígitos? E com o máximo de 5000 dígitos?

{zwsp} +
*Solução:* 


De acordo com Gauss, o número de primos no intervalo latexmath:[$[2,x\]$] é aproximadamente latexmath:[$0,4342 x / (\log_{10}{x})$]. 

Para até 500 dígitos, temos latexmath:[$0,4342 \times \frac{10^{500}}{500} = 0,8684 \times 10^{497}$]; (para comparação, o número de prótons no universo observável é na ordem de latexmath:[$10^{80}$]).

Para até 501 dígitos, temos latexmath:[$0,4342 \times \frac{10^{501}}{501} = 0,8667 \times 10^{498}$];

Para até 5000 dígitos, temos latexmath:[$0,4342 \times \frac{10^{5000}}{5000} = 0,8684 \times 10^{4997}$];
====

[[Ex-Primo]]
.{zwsp}
====
Você quer dividir o intervalo entre 2 e latexmath:[$10^{400}$] em 100 segmentos que tenham aproximadamente o mesmo número de primos. Como você fará?

{zwsp} +
*Solução:* 

O número de primos no intervalo total é de cerca de latexmath:[$0,4342 \times \frac{10^{400}}{(\log_{10}{10^{400}})} = 0,4342 \times \frac{10^{400}}{400} = 0,1086 \times 10^{398}$]. Portanto, cada um dos 100 intervalos deve ter cerca de latexmath:[$0,1086 \times 10^{396}$] primos.
 
O 1º intervalo deve ir de 2 até latexmath:[$n_1$], onde latexmath:[$\frac{0,4342 n_1}{(\log_{10}{n_1})} = 1 \times 0,1086 \times 10^{396}$]. Resolva latexmath:[$n_1$], mesmo que de forma aproximada.

O 2º intervalo deve ir de latexmath:[$n_1$] até latexmath:[$n_2$], onde latexmath:[$\frac{0,4342 n_2}{(\log_{10}{n_2})} = 2 \times 0,1086 \times 10^{396}$]. Resolva latexmath:[$n_2$], mesmo que de forma aproximada.

O 3º intervalo deve ir de latexmath:[$n_2$] até latexmath:[$n_3$], onde latexmath:[$\frac{0,4342 n_3}{(log_{10}{n_3})} = 3 \times 0,1086 \times 10^{396}$]. Resolva latexmath:[$n_3$], mesmo que de forma aproximada.

 ...
====

.{zwsp}
====
Você quer encontrar um primo que pode chegar a ter até 400 dígitos, e quer dividir (de uma vez por todas, sem refazer a divisão) o trabalho 
entre 104 computadores. Suponha que, uma vez que o computador sugira um primo para ser testado, o teste é dispendioso. Como você fará? Dará
 a cada computador um intervalo de mesmo comprimento de inteiros, para ele analisar? (isto é, dirá ao computador 1 para procurar entre 2 e 
 latexmath:[$10^{400-4}$], ao computador 2 para começar daí e ir até latexmath:[$2 \times 10{400-4}$], ..., ao computador 10.000 para ir de 
 latexmath:[$(10000-1) \times 10^{396}$] até latexmath:[$10^{400}$])? Por que sim? Por que não? Ou você teria uma melhor divisão de trabalho
 entre os computadores (supondo que a divisão só pode ser feita uma vez)? Qual?
 
{zwsp} +
*Solução:* 

Eu não usaria o esquema proposto porque a ``densidade'' dos primos vai diminuindo, de modo que os últimos computadores vão achar muito menos primos para testar (supondo que o teste é dispendioso) do que os primeiros que acharão muitos mais primos em seus intervalos).
Lembrando que o número de primos menores que ou iguais a latexmath:[$x$], é grosseiramente aproximado por latexmath:[$x/ \ln{x}$], eu usaria o esquema de divisão das tarefas proposto no <<Ex-Primo>>.
====

==== Atividades

NOTE: Exercícios propostos, do livro do Prof. Manoel Lemos em http://www.impa.br/opencms/pt/biblioteca/pm/PM_04.pdf . Escolha e faça pelo menos 1/3 deles, espaçados, de diferentes tipos.

//_

. Mostre que todo número natural composto latexmath:[$n$] possui um divisor menor ou igual a latexmath:[$\sqrt{n}$].
. Fatore os seguintes números como produto de primos: latexmath:[$5^{16} – 1$]; latexmath:[$7^{12} – 1$]; e latexmath:[$2^{15} + 1$].
. Um número primo da forma latexmath:[$2^n − 1$], para latexmath:[$n \in \mathbb{N}$], é dito de Mersenne. Quando isto ocorre, mostre que latexmath:[$n$] tem de ser primo.
. A recíproca do exercício anterior vale? Isto é, se latexmath:[$n$] é primo, então latexmath:[$2^n − 1$] tem que ser primo?
. Um número primo da forma latexmath:[$2^n + 1$], para latexmath:[$n \in \mathbb{N}$], é dito de Fermat. Quando isto ocorre, mostre que latexmath:[$n$] tem de ser uma potência de 2.
. Encontre o expoente da maior potência de 2 que divide latexmath:[$100!$] (100 fatorial). 
. Seja latexmath:[$p$] um número primo e latexmath:[$n$] um inteiro positivo. Mostre que o expoente da maior potência de latexmath:[$p$] que divide latexmath:[$n!$] é latexmath:[$\\sum_{i=1}^{n}{\frac{n}{p^i}}$] 
. Qual dentre os números 501, 521, 541, 561 e 581 é de Carmichael?
. Mostre que todo número de Carmichael é divisível por pelo menos três primos distintos.
. Encontre todos os números de Carmichael da forma latexmath:[$3pq$], onde latexmath:[$p$] e latexmath:[$q$] são números primos distintos.
. Para um natural latexmath:[$k$], suponha que latexmath:[$6k+1$], latexmath:[$12k+1$] e latexmath:[$18k+1$] são todos primos. Mostre que latexmath:[$n_k = (6k+1)(12k+1)(18k+1)$] é de Carmichael.
. Encontre todos os números de Carmichael da forma latexmath:[$n_k$], para latexmath:[$k \leq 10$].

=== Divisibilidade

latexmath:[$b$] *divide* latexmath:[$a$] (denotado latexmath:[$b \vert a$]) se latexmath:[$bk = a$], para algum inteiro latexmath:[$k$]. latexmath:[$b$] é chamado de um *divisor* de latexmath:[$a$], latexmath:[$a$] é chamado de um *múltiplo* de latexmath:[$b$].

*Ache todos os divisores de um dado inteiro latexmath:[$x$]:*
 
A partir do Teorema Fundamental da Aritmética, sabemos que latexmath:[$x$] é unicamente representado pelo produto de seus fatores primos. (
use http://primes.utm.edu/lists/small/10000.txt.) Cada divisor é o produto de algum subconjunto desses fatores primos. Tais subconjuntos 
podem ser construídos usando técnicas de backtracking, assim, por exemplo: latexmath:[$165 = 3 \times 5 \times 11$]. Seus divisores são 
1,3,5,11,15,33,55,165, mas devemos ter cuidado com fatores primos duplicados. Por exemplo, a fatoração de 12 em primos tem três termos (2, 
2, e 3), e poderia parecer que 12 tem latexmath:[$2^3 = 8$] divisores (correspondente ao conjunto potência, o conjunto vazio correspondente 
ao divisor 1), mas 12 tem apenas 6 divisores (1, 2, 2, 3, 4, 6, 12) (backtracking mal feito contaria latexmath:[$2 \times 2$] de duas 
maneiras, e contaria o resultado de latexmath:[$2 \times 3$] como diferente do resultado de latexmath:[$3 \times 2$], resultando em 
latexmath:[$\{1,2,2,3,2,2,3,4,6,6,12\}$]).

==== Máximo Divisor Comum (latexmath:[$mdc$]) (Greatest Common Divisor - latexmath:[$gcd$])

O maior divisor comum de dois ou mais números é chamado de máximo divisor comum (latexmath:[$mdc$]) desses números. 

*Propriedades:*

* Cada divisor comum de latexmath:[$a$] e latexmath:[$b$] é um divisor de latexmath:[$mdc(a,b)$].
* latexmath:[$mdc(a,b)$], onde latexmath:[$a$] e latexmath:[$b$] não são ambos zero, pode ser definido, alternativamente e equivalentemente,
 como o menor número inteiro positivo latexmath:[$d$] que pode ser escrito da forma latexmath:[$d = ap+bq$], onde latexmath:[$p$] e 
 latexmath:[$q$] são números inteiros . Esta expressão é denominada *identidade de Bézout*. Números latexmath:[$p$] e latexmath:[$q$] como 
 este pode ser calculados com o algoritmo estendido de Euclides.
* latexmath:[$mdc(a,0) = \vert a \vert$], para latexmath:[$a \not= 0$], uma vez que qualquer número é um divisor de 0, e o maior divisor de latexmath:[$a$] é latexmath:[$|a|$]. Isto é usado geralmente como o caso base no algoritmo de Euclides.
* latexmath:[$mdc(x,x) = x$] (Idempotência)
* Se latexmath:[$a$] divide o produto latexmath:[$b \cdot c$], e latexmath:[$mdc(a,b) = d$], então latexmath:[$a/d$] divide latexmath:[$c$].
* Se latexmath:[$m$] é um inteiro não negativo, então latexmath:[$mdc(m \cdot a, m \cdot b) = m \cdot mdc(a,b)$].
* Se latexmath:[$m$] é um número inteiro qualquer, então latexmath:[$mdc(a + m \cdot b, b) = mdc(a,b)$].
* Se latexmath:[$m$] é um não nulo divisor comum de latexmath:[$a$] e latexmath:[$b$], então, latexmath:[$mdc(a/m, b/m) = mdc(a,b)/m$].
* O latexmath:[$mdc$] é uma *função multiplicativa* no seguinte sentido: se latexmath:[$a_1$] e latexmath:[$a_2$] são relativamente primos, então latexmath:[$mdc(a_1 \cdot a_2,b) = mdc(a_1,b) \cdot mdc(a_2,b)$].
* O latexmath:[$mdc$] é uma *função comutativa*: latexmath:[$mdc(a,b) = mdc(b,a)$].
* O latexmath:[$mdc$] é uma *função associativa*: latexmath:[$mdc(a, mdc(b,c)) = mdc(mdc(a,b), c)$].
* O latexmath:[$mdc$] de três números pode ser calculado como latexmath:[$mdc(a, b, c) = mdc(mdc(a,b),c)$], ou, de algum modo diferente, aplicando comutatividade e associatividade. Isso pode ser estendido a qualquer número de números.
* latexmath:[$mdc(a, b)$], está estreitamente relacionada com o mínimo múltiplo comum latexmath:[$mmc(a, b)$], temos: +
[latexmath]
++++
\[mdc(a,b) \cdot mmc(a, b) = a \cdot b\]
++++
Esta fórmula é muitas vezes usada para computar mínimo múltiplos comuns: primeiro se calcula a latexmath:[$mdc$] com o algoritmo de Euclides, e então se divide o produto dos números indicados por seu latexmath:[$mdc$].

* As seguintes versões da distributividade são verdadeiras:
**latexmath:[$mdc(a, mmc(b,c)) = mmc(mdc(a,b), mdc(a,c))$];
**latexmath:[$mmc(a, mdc(b,c)) = mdc(mmc(a,b), mmc(a,c))$].
* É útil se definir latexmath:[$mdc(0, 0) = 0$] e latexmath:[$mmc(0,0) = 0$], porque então os números naturais tornam-se um reticulado distributivo completo com latexmath:[$mdc$] como operação supremo (também chamada de ``join'', mesmo símbolo de ``or'') e latexmath:[$mmc$] como operação ínfimo (também chamada de ``meet'', mesmo símbolo de ``and''). 

*Primeiro método*, simples-direto-ineficiente, *de calcular latexmath:[$mdc$] de dois naturais:* 

Suponhamos que os números são latexmath:[$a = 126$] e latexmath:[$b = 420$]; +
Ache todos os divisores do menor dos números (latexmath:[$a = 126$]. Fatorando em primos ( http://primes.utm.edu/lists/small/10000.txt. ), 
latexmath:[$a= 2 \times 3 \times 3 \times 7$]; achando os produtos das combinações distintas deles, os divisores de latexmath:[$a$] são, 
ordenados crescentemente latexmath:[$\{1,2,3,6,7,9,14,18,21,42\}$]); +
Depois, em ordem decrescente, teste cada um deles até achar o maior deles que divida o outro número. (tente 42 e obterá sucesso.)

Ou, somente muito pouco diferente:

Suponhamos que os números são latexmath:[$a = 126$] e latexmath:[$b = 420$]; +
Decomponha cada um em seus fatores primos (use http://primes.utm.edu/lists/small/10000.txt ): latexmath:[$126 = 2^1 \times 3^2 \times 5^0 \times 7^1$]; latexmath:[$420 = 2^2 \times 3^1 \times 5^1 \times 7^1$]. +
O resultado será o produto de cada fator que aparece _em comum_ na fatoração de latexmath:[$a$] e de latexmath:[$b$], tomado com seu _menor_ expoente latexmath:[$2^1 \times 3^1 \times 5^0 \times 7^1 = 42$]. 

Outro exemplo (vou realçar os quocientes quando se aplicarem a todos os números): latexmath:[$mdc(70,90,120)$] 

[width="40%",cols=">2a,<1a", frame="none"]
|====
| 70  90  120
 35  45  60 
 35  45  30 
 35  45  15 
 35  15  5  
 35  5   5  
 7   1   1  
 1   1   1  
| 2<
 2
 2
 3
 3
 5<
 7
|====

Ao final, multiplicamos somente os quocientes realçados.

*Algoritmo de Euclides* (1o algoritmo interessante em toda a História, que ``quebrou barreiras'', muito mais eficiente (latexmath:[$O(\log{n})$]) que todos os rivais) (é o avô de todos os algoritmos: tem mais de 2300 anos e não existe melhor): 

Baseado em 2 propriedades (prove-as em casa?):

* Se latexmath:[$b|a$], então latexmath:[$mdc(a,b) = b$].
* Se latexmath:[$a = bt + r$] para inteiros latexmath:[$t, r$], então latexmath:[$mdc(a,b) = mdc(b, r)$].

_Aprendemos no Ensino Fundamental:_ 

[quote]
mdc(maior, menor) := if menor = 0 then maior else mdc(menor, resto da divisão inteira maior/menor )

[width = "25%", cols="^,^,^,^"]
|====
|-   |1   |9    |-
|420 |378 |*42* |...0
|378 |378 |...  |...
|42  |0   |...  |...
|====

 Quocientes ArguEsq divinteira ArguAbaixo (primeira célula vazia)	
 Argumentos (inicialmente {maior, menor} )
 Multiplicação ArguDir x QuocDir 
 Resto = ArguAcima - MultiplicaçãoAcima (transferir para ser ArguDir)

Outro exemplo:

[width = "40%", cols="^,^,^,^,^,^,^"]
|====
|-   |5  |4 |1 |1 |2   |
|120 |23 |5 |3 |2 |*1* |0
|115 |20 |3 |2 |2 |    |
|5   |3  |2 |1 |0 |    |
|====

 Quocientes ArguEsq divinteira ArguAbaixo (primeira célula vazia)
 Argumentos (inicialmente {maior, menor} )
 Multiplicação ArguDir x QuocDir 	
 Resto = ArguAcima - MultiplicaçãoAcima (transferir para ser ArguDir)	

*Algoritmo de Euclides iterativo:*

----
AlgoritmoDeEuclides(a: inteiro; b: inteiro): inteiro
variáveis
   divisor: inteiro
   dividendo: inteiro
   c: inteiro
início
   dividendo = a
   divisor = b
   enquanto resto(dividendo/divisor) ≠ 0
   início
      c = resto(dividendo/divisor)
      dividendo = divisor
      divisor = c
   fim-enquanto
   
   AlgoritmoDeEuclides = divisor
fim-função
----

*Algoritmo de Euclides recursivo:*

----
AlgoritmoDeEuclides(a: inteiro; b: inteiro): inteiro
início
   se b = 0 então
      AlgoritmoDeEuclides = a
   senão
      AlgoritmoDeEuclides = AlgoritmoDeEuclides(b,resto(a,b))
   fim-se
fim-função
----

*Implementação de Euclides em C* (cuidado para prever o caso p=q=0):

[source,c]
----
/* Find the gcd(p,q) and x,y such that p*x + q*y = gcd(p,q) */
long gcd(long p, long q, long *x, long *y)
{
  long x1,y1; /* previous coefficients */
  long g; /* value of gcd(p,q) */
  if (q > p) return(gcd(q,p,y,x));
  if (q == 0) {
    *x = 1;
    *y = 0;
    return(p);
  }
  g = gcd(q, p%q, &x1, &y1);
  *x = y1;
  *y = (x1 - floor(p/q)*y1);
  return(g);
}
----

*Algoritmo de Euclides estendido:*

Além de encontrar o máximo divisor comum de inteiros latexmath:[$a$], latexmath:[$b$], como o algoritmo de Euclides faz, também encontra números inteiros latexmath:[$x$], latexmath:[$y$] (um dos quais é tipicamente negativo) que satisfazem a *identidade de Bézout*

[latexmath]
++++
\[ax + by = mdc(a,b)\]
++++

Por exemplo:

latexmath:[$120 \times (-9) + 23 \times (47) = mdc(120,23)$]. Aqui, latexmath:[$a = 120$], latexmath:[$b = 23$], latexmath:[$x = -9$], latexmath:[$y = 47$]. Realmente, latexmath:[$-1080 + 1081 = 1 = mdc(120,23) = mdc(23,5) = mdc(4,3) = mdc(3,1) = 1$].

O algoritmo estendido de Euclides é particularmente útil quando latexmath:[$a$] e latexmath:[$b$] são *relativamente primos* (também chamados de *co-primos* e ditos serem *primos entre si*), (dois números latexmath:[$a$], latexmath:[$b$] são co-primos se o único fator comum entre eles é 1. 10 e 21 são co-primos, porque latexmath:[$10=5 \times 2 \times 1$] e latexmath:[$21=7 \times 3 \times 1$], e esses números só têm 1 como fator em comum) uma vez que (latexmath:[$x$] é o inverso multiplicativo de latexmath:[$a$]) latexmath:[$\mod{b}$], e (latexmath:[$y$] é o inverso multiplicativo de latexmath:[$b$]) latexmath:[$\mod{a}$].

latexmath:[$x$] é o inverso multiplicativo módulo latexmath:[$m$] de um inteiro latexmath:[$a$] (e pode ser escrito latexmath:[$a^{-1} \mod{m})$] se (latexmath:[$ax  \equiv  1$]) latexmath:[$\mod{m}$].

Por exemplo, se latexmath:[$m =3$], então 2 é o inverso multiplicativo de 23, porque latexmath:[$(23 \times 2) \mod{3} = ((23 \mod{3}) \times (2 \mod{3})) \mod{3} = (2 \times 2) \mod{3} = 4 \mod{3} = 14$].

No exemplo lá em cima, (-9 é o inverso multiplicativo de 120) latexmath:[$\mod{23}$], pois latexmath:[$(23-9)=14$] e (latexmath:[$14 \times 120$]) latexmath:[$\mod{23} = \cdots = 1$]. (47 é o inverso multiplicativo de 23) latexmath:[$\mod{120}$], pois (latexmath:[$47 \times 23$]) latexmath:[$\mod{120} = \cdots = 1$]

[latexmath]
++++
\[mdc(120,23) = 120 \times(-9) + 49 \times (23) = -1080 + 1081 = 1\]
++++

*Euclides Estendido, Algoritmo Recursivo:*

----
function extended_gcd(a, b)   // retorna um par [(x,y), de modo que ax + by = mdc(a,b)]
    if b = 0
        return (1, 0)
    else
        q := a divinteira b
        r := a – b*q 
        (s, t) := extended_gcd(b, r)
        return (t, s - q*t)
----

*Euclides Estendido, Código em C:*


[source,c]
----
#include <stdio.h>
#include <stdlib.h>

/* Aritmética modular é também considerada como o "algoritmo do relógio".

Ao extrair o modulo 12, como resposta possível pode-se ter números de 0 a 11. Nunca negativo, pois a ideia é de um relógio com 12 posições, sendo a primeira o zero e a última o 11.

Porém o operador de módulo do C (operador %) computa apenas o resto da divisão e gera números negativos. Em C:

-2 mod 12 = -2 (não está entre 0 e 11)
2 mod -12 = 2  (não está entre -11 e 0)

O C dizer que -2 mod 12 é -2 significa dizer que ele está a -2 de distância do final do relógio, ou seja, está em 10 (o início e também o final do relógio é o zero).

Dizer que 2 mod -12 significa um relógio ao contrário (0, -1, -2, -3, .. -11, andando no sentido anti-horário) e que o valor 2 está a 2 posições de distância do 0, ou seja,está em -10.

Nesta aritmética modular o resultado da operação PRECISA SER do mesmo sinal do divisor.

Observou-se que o operador de módulo do python (%) não tem este comportamento, calculando o módulo não negativo. A biblioteca bn.h do openssl possui ambos, tanto a função BN_mod que simplesmente retorna o resto da divisão (comportamento igual ao % do C) como a função BN_nnmod que calcula o módulo não negativo.

Nesta versão em C resolveu-se fazer uma pequena correção na resposta dada pelo operador de módulo, pois o algoritmo de Euclides precisa do módulo positivo.
*/
long mod(long a, long b)
{
    long r = a % b;

    /* Uma correção é necessária se r e b não forem do mesmo sinal */

    /* se r for negativo e b positivo, precisa corrigir */
    if ((r < 0) && (b > 0))
	return (b + r);

    /* Se r for positivo e b negativo, nova correção */
    if ((r > 0) && (b < 0))
	return (b + r);

    return (r);
}

long euclides_ext(long a, long b, long c)
{
    long r;
    r = mod(b, a);
    if (r == 0) {
	return (mod((c / a), (b / a)));	// retorna (c/a) % (b/a)
    }
    return ((euclides_ext(r, a, -c) * b + c) / (mod(a, b)));
}
int main(int argc, char *argv[])
{
    long p, q, e, qq, n, d;

    /* O objetivo desta implementação do algoritmo de Euclides estendido é o cálculo do valor do D da chave privada correspondente a Ke=(n,e) http://www.vivaolinux.com.br/artigo/Criptografia-assimetrica-com-o-RSA/ para isto são necessários fornecer o p, o q e o valor de e */
    if (argc != 4) {
	fprintf(stderr, "ERRO. faltou passar valor de p, q, e\n");
	fprintf(stderr, "Forma de uso:\n");
	fprintf(stderr, "\t%s p q e\n", argv[0]);
	return (1);
    }

    /* pegando os valores de p, q e n fornecidos como argumentos do main */
    p = atol(argv[1]);
    q = atol(argv[2]);
    e = atol(argv[3]);

    /* calculando o n */
    n = p * q;

    /* calculando o quociente de Euller, chamado aqui de qq */
    qq = (p - 1) * (q - 1);

    /* chamando a função que calcula o d. Ela retorna um número que case na expressão: (d*e) mod qq = X para que M^(d*e) mod N = M
       Tem-se o e e o qq. Para o RSA o X deve ser 1, pois d*e mod qq = 1
     */
    d = euclides_ext(e, qq, 1);

    printf("\nVALORES CALCULADOS:\n");
    printf("N  = %10li\nE  = %10li\nqq = %10li\nD  = %10li\n", n, e, qq, d);
    printf("\n*** Verifique com ***\n");
    printf("\techo \"(%li * %li) %% %li\"|bc\n\n", d, e, qq);
    printf("\t(deve resultar em 1)\n\n\n");
----

NOTE: Veja, em http://pt.wikibooks.org/wiki/Teoria_de_n%C3%BAmeros/Divisibilidade, úteis regras de divisibilidade por 2,3,4,5,6,7,8,9,10,11. Porque funcionam pode ser visto em http://webspace.ship.edu/msrenault/divisibility/StupidDivisibilityTricks.pdf ou suas referências.

//_

==== Mínimo Múltiplo Comum (latexmath:[$mmc$]) (Least Common Multiple, latexmath:[$lcm$])

O *mínimo múltiplo comum* (latexmath:[$mmc$]) de dois inteiros latexmath:[$a$], latexmath:[$b$] é o menor inteiro positivo que é múltiplo 
simultaneamente de latexmath:[$a$] e de latexmath:[$b$]. Se não existir tal inteiro positivo, por exemplo, se latexmath:[$a = 0$] ou 
latexmath:[$b = 0$], então definimos que latexmath:[$mmc(a, b) = 0$].

É evidente que latexmath:[$mmc(x, y) \geq max(x, y)$]. Do mesmo modo, uma vez que latexmath:[$x \cdot y$] é um múltiplo de ambos latexmath:[$x$] e latexmath:[$y$], então latexmath:[$mmc(x, y) \leq x \cdot y$]. A única maneira pela qual pode haver um múltiplo comum menor que latexmath:[$xy$] é se há algum fator não trivial (i.e., diferente de 0 e de 1) partilhado entre latexmath:[$x$] e latexmath:[$y$]. Esta observação, juntamente com o algoritmo de Euclides, oferece uma maneira eficiente para computar mínimo múltiplo comum: se nem latexmath:[$a$] nem latexmath:[$b$] são zero, o mínimo múltiplo comum pode ser computado usando o Algoritmo de Euclides (para latexmath:[$mdc$]):

[width="80%",cols="<,<",grid="none",frame="none"]
|====
|se nem latexmath:[$a=0$] nem latexmath:[$b=0$], então	|latexmath:[$mmc(a,b) = (a \cdot b) / mdc(a,b)$]
|senão, 					                            |latexmath:[$mmc(a,b) = 0$]
|====

Sempre use a regra ``cancelar antes de multiplicar'': latexmath:[$mmc (24000, 36000)$], simplificado dividindo por 12000, dá latexmath:[$12000 \times mmc(2,3) = 12000 \times 6 = 72000$].

Considerado como operação binária, o latexmath:[$mmc$] de dois inteiros positivos tem as propriedades:

* *Comutativa*: latexmath:[$mmc(a,b) = mmc(b,a)$]
* *Associativa:* latexmath:[$mmc(a,mmc(b,c)) = mmc(mmc(a,b),c)$]
* *É idempotente:* latexmath:[$mmc(a,a) = a$]
* *1 é o elemento neutro:* latexmath:[$mmc(a,1) = a$]
* E a multiplicação é distributiva com o latexmath:[$mmc$]: latexmath:[$a \times mmc(b, c) = mmc(ab, ac)$]

Mínimo múltiplo comum surge quando queremos calcular a periodicidade simultânea de dois distintos eventos periódicos. Quando é o próximo ano (após 2000) em que a eleição presidencial (que acontece a cada 4 anos) vai coincidir com o censo (que acontece a cada 10 anos)? Os eventos coincidem cada vinte anos, porque latexmath:[$mmc(4,10) = 20$].

_Aprendemos no Ensino Fundamental:_

Suponhamos que os números são latexmath:[$a = 126$] e latexmath:[$b = 420$]; +
Decomponha cada um em seus fatores primos (use http://primes.utm.edu/lists/small/10000.txt): latexmath:[$126 = 2^1 \times 3^2 \times 5^0 \times 7^1$]; latexmath:[$420 = 2^2 \times 3^1 \times 5^1 \times 7^1$]. +
O resultado será o produto de cada fator (não precisa ser em comum) tomado com seu maior expoente latexmath:[$2^2 \times 3^2 \times 5^1 \times 7^1 = 1260 = 42$].

Outro exemplo: latexmath:[$mmc(70,90,120)$]

[width="40%",cols=">2a,<1a", frame="none"]
|====
| 70  90  120
 35  45  60 
 35  45  30 
 35  45  15 
 35  15  5  
 35  5   5  
 7   1   1  
 1   1   1  
| 2<
 2
 2
 3
 3
 5<
 7
|====
 
O latexmath:[$mmc$] é o produto de todos os fatores: latexmath:[$mmc(70,90,120) = 2^3 \times 3^2 \times 5 \times 7 = 2520$]


.(mdc):
====
Etapa por etapa (usando a fórmula recursiva ou a construindo a tabela) mostre qual é o máximo divisor comum (latexmath:[$mdc$]) de 11025 e 3872. Que mais pode você dizer sobre esses números?

{zwsp} +
*Solução:* (vamos resolver de vários modos):

Como aprendemos mais ou menos aos 10 anos de idade, tudo à mão, sem calculadora:

[width="100%",cols="2<,2<,2<,2<,1<,1<,1<,1<,1<,1<,1<,1<,1<",frame="none",grid="none"]
|====
|Quociente      |        |        |2     |1	   |5    |1   |1  |4   |2   |1 |9   |2
|Números	    |*11025* |*3872*  |3281  |591  |326  |265 |61 |21  |19  |2 |*1* |	
|Multiplicações |-7744   |-3281   |-2955 |-326 |-265 |244 |42 |-19 |-18 |2 |    |		
|Restos         |3281    |591     |326   |265  |61   |21  |19 |2   |1   |0 |    |	
|====

Ou, depois que começamos a usar calculadora que tinha a função módulo:

[width="100%",cols="2<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<",frame="none",grid="none"]
|====
|Números	                        |11025 |3872 |3281 |591 |326 |265 |61 |21 |19 |2 |*1*
|latexmath:[$NorOeste \mod{Norte}$] |      |3281 |591  |326 |265 |61  |21 |19 |2  |1 |0
|====

(por exemplo, na segunda célula da linha de baixo: latexmath:[$11025 mod 3872 = 3281$])

Doutro modo, usando a fórmula recursiva:

 mdc(Maior,Menor)   = mdc(Menor, (Maior % Menor))
 mdc (11025,3872)	= mdc (3872, (11025 % 3872) =
 mdc(3872,3281)	    = mdc(3281, (3872 % 3281)) =
 mdc(3281,591)	    = mdc(591, (3281 % 591)) =
 mdc(591,326)	    = mdc(326, (591 % 326)) =
 mdc(326,265)	    = mdc(265, (326 % 265)) =
 mdc(265,61)        = mdc(61, (265 % 61)) =
 mdc(61,21)		    = mdc(21, (61 % 21)) =
 mdc(21,19)		    = mdc(19, (21 % 19)) =
 mdc(19,2)		    = mdc(2, (19 % 2)) =
 mdc(2,1)		    = mdc(1, (2 % 1)) =
 mdc(1,0)		    = 1

Doutro modo, fatorando os números em fatores primos, depois tomando em menor expoente os fatores primos comuns aos dois números:

latexmath[$11025 = 3^2 \cdot 5^2 \cdot 7^2$] + 
latexmath[$3872 = 2^5 \cdot 11^2$] +
latexmath[$mdc(11025,3872) = 1$]
   
(note que, para enormes números cujas fatorações podem exigir tentativas de divisão por grande número de primos, o algoritmo de Euclides é o mais eficiente de todos os que vimos)
====
