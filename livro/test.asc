

























 






`mdc(Maior,Menor)	 = mdc(Menor, (Maior % Menor))
mdc (11025,3872)	= mdc (3872, (11025 % 3872) =
mdc(3872,3281)	    = mdc(3281, (3872 % 3281)) =
mdc(3281,591)	    = mdc(591, (3281 % 591)) =
mdc(591,326)	    = mdc(326, (591 % 326)) =
mdc(326,265)	    = mdc(265, (326 % 265)) =
mdc(265,61)		    = mdc(61, (265 % 61)) =
mdc(61,21)		    = mdc(21, (61 % 21)) =
mdc(21,19)		    = mdc(19, (21 % 19)) =
mdc(19,2)		    = mdc(2, (19 % 2)) =
mdc(2,1)		    = mdc(1, (2 % 1)) =
mdc(1,0)		    = 1`

Doutro modo, fatorando os números em fatores primos, depois tomando em menor expoente os fatores primos comuns aos dois números:

latexmath[$11025 = 3^2 \cdot 5^2 \cdot 7^2$] + 
latexmath[$3872 = 2^5 \cdot 11^2$] +
latexmath[$mdc(11025,3872) = 1$]
   
(note que, para enormes números cujas fatorações podem exigir tentativas de divisão por grande número de primos, o algoritmo de Euclides é o mais eficiente de todos os que vimos)
====

=== Aritmética Modular

Algumas vezes não estamos interessados no resultado completo de operações aritméticas sobre números ``quilométricos'', mas somente nela módulo alguma coisa. 

.{zwsp}
====
Hoje é domingo. Que dia da semana será daqui a 1 milhão de dias? Bem, latexmath[$1000000 \mod{7} = 1$], portanto cairá num domingo + 1, ou seja, numa segunda-feira. 

Quanto é ((número de 10 trilhões de dígitos) elevado a (número de 3000 dígitos)) módulo (número primo de 400 dígitos)?
====

*Propriedades da Aritmética Modular:*

* latexmath[$(x + y) \mod n = ((x \mod n) + (y \mod n)) \mod n$]
** Exemplo: latexmath[$(90012 + 80053) \mod 5 = ((90012 \mod 5) + (80053 \mod 5)) \mod 5 = (2 + 3) \mod 5 = 5 \mod 5 = 0$] (note que para calcularmos latexmath[$n \mod 5$] basta nos ocuparmos do último dígito de latexmath[$n$]). 
* latexmath[$(x - y) \mod n   =   ((x \mod n) - (y \mod n)) \mod n$]
** Exemplo: latexmath[$(90012 - 80053) \mod 100 = ((90012 \mod 100) - (80053 \mod 100)) \mod 100  = (12 – 53) \mod 100 = −41 \mod 100 = 59 \mod 100 = 59$]
* latexmath[$(xy) \mod n = ((x \mod n)(y \mod n)) \mod n$]
** Exemplo: latexmath[$((90012 \times 80053)) \mod 100 = ((90012 \mod 100) \times (80053 \mod 100)) \mod 100  = (12 \times 53) \mod 100 = 636 \mod 100 = 36$] (para divisão, ver abaixo, em <<sec-7-5>>).

*Aplicações da Aritmética Modular:*

* *1ª Aplicação:* Achar o último dígito — Qual é o último dígito de (longa expressão aritmética,por enquanto sem divisão, com grandes inteiros)?
* *2ª Aplicação:* Cálculos a Respeito de Calendários;
* *3ª Aplicação:* Exponenciação modular: Pela definição de potência, podemos calcular latexmath[$a^n$] assim: +
`function exposeq(a,n)
  r := a
  for i := 1 to n-1 do r := a*r
  return r` +
Mas isto é muito ruim pois, no pior caso, o número de multiplicações é assintoticamente proporcional a latexmath[$n$], isto é, é latexmath[$O(n)$].

Uma conhecida técnica geral para solução de problemas é a ``Divida e Conquiste'':

`Se o tamanho do problema é suficientemente pequeno, então resolva-o diretamente 
senão 
  divida-o em 2 ou mais subproblemas menores de tamanhos os mais iguais possíveis; 
  resolva-os; 
  retorne a apropriada junção dessas soluções dos subproblemas `
  
Usando a técnica de ``Divida e Conquiste'', a exponenciação modular fica bem mais eficiente:

----
function expoDC(a,n)            // recursivo
  if n = 1 then return a
  if par(n) then return(expoDC(a, n/2))^2
  return a * expoDC(a, n-1)
----

ou

----
function expoiter(a,n)		// tempo semelhante expoDC
  i := n; r := 1; x := a
  while i > 0 do
    if i ímpar(i) then r := r*x
  x := x^2
  i := i÷2		{divisão inteira}
  return r
----

Melhorou muito, pois o número de multiplicações caiu para latexmath:[$O(\log n)$]

Mas, em MUITAS aplicações, a base latexmath:[$a$] tem milhões de dígitos e temos que usar os lentos módulos de aritmética de precisão 
``infinita''  embutidos da biblioteca da linguagem (BigNum), e a potência latexmath:[$n$] tem milhares de dígitos, levaria séculos para 
fazer os cálculos; mas só precisamos do resultado módulo um número de algumas centenas ou milhares de dígitos, e tudo pode ser feito 
extraordinariamente mais rápido (em microsegundos?), usando aritmética modular.


==== Problema 374 do ACM Programming Contest (BigMod)

NOTE: No exame, no máximo, no máximo, poderá haver alguma pergunta conceitual do tipo ``que significa... qual a vantagem... qual a diferença... como funciona... qual a ideia básica...'' Não será pedido mais que isso: nem prova de corretude, nem prova de complexidade, etc. Mas a implementação seria um ótimo trabalho de casa depois de você ter dominado 2 disciplinas de programação.

Calcule +
[latexmath]
++++
\[R := B^P \mod M\]
++++

para valores enormes para latexmath:[$B$], latexmath:[$P$], e latexmath:[$M$], usando um algoritmo eficiente (sim, este programa tem uma restrição quanto ao tempo!)

latexmath:[$(a^b) \mod c = ((a \mod c)^b) \mod c $] (faça as multiplicações em aritmética modular) +
(ache um contra-exemplo e verá que é falso latexmath:[$(a^b) \mod c = ((a \mod c)^{(b \mod c)}) \mod c$])

Em Python:

[source, python]
----
def ExpoModularRec(BaseMdlada, Expo, Modulo):
  if Expo == 1:
    Resposta = BaseMdlada
  elif Expo == 0:
    Resposta = 1; # optei por fazer 0^0 = 1 e não 0
  elif BaseMdlada == 0:
    Resposta = 0
  elif BaseMdlada == 1:
    Resposta = 1
  elif Expo % 2 == 0:
    Aux = ExpoModularRec(BaseMdlada,(Expo/2), Modulo)
    Resposta = (Aux * Aux) % Modulo
  else: Resposta = (BaseMdlada * 
       ExpoModularRec(BaseMdlada, (Expo -1), Modulo)) % Modulo
  return Resposta
----

NOTE: 4ª Aplicação: Usando a 3ª aplicação (Exponenciação Modular) de Aritmética Modular, chegamos ao: *Algoritmo de criptografia RSA* (RSA Encryption Algorithm) - a nossa mensagem é criptografada por codificá-lo como um inteiro latexmath:[$m$], depois elevá-la a uma potência latexmath:[$k$] (onde latexmath:[$k$] é chamada de chave pública ou chave de encriptação), e extrair o latexmath:[$\mod n$], para, assim, chegar ao resultado. Como latexmath:[$m$], latexmath:[$n$], e latexmath:[$k$] são todos inteiros enormes, a eficiente computação de (latexmath:[$m^k \mod n$]) requer as ferramentas que desenvolvemos anteriormente. Detalhes em http://en.wikipedia.org/wiki/RSA_(algorithm) .

//_

.{zwsp}
====
Compute latexmath:[$2^{60} \mod 101$] usando exponenciação modular latexmath:[$(a^b) \mod c = ((a \mod c)^b) \mod c$] e divida e conquiste. Mostre todas as etapas.

{zwsp} +
*Solução:*

latexmath:[$2^{60} = (2^{30})^2 = ((2^{15})^2)^2 = ((2 \times 2^{14})^2)^2 = ((2 \times (2^7)^2)^2)^2 = ((2 \times(2 \times 2^6)^2)^2)^2 = ((2 \times (2 \times (2^3)^2)^2)^2)^2 = ((2 \times (2 \times (2 \times (2^2))^2)^2)^2)^2 = ((2 \times (2 \times (2 \times (2^2))^2)^2)^2)^2$]

Em outras palavras:

latexmath:[$2^{60} = (2^{30})^2$] +
latexmath:[$2^{30} = (2^{15})^2$] +
latexmath:[$2^{15} = 2 \times (2^7)^2$] +
latexmath:[$2^7 = 2 \times (2^3)^2$] +
latexmath:[$2^3 = 2 \times (2^1)^2$] +
latexmath:[$2^1 = 2$]

Usando aritmética latexmath:[$\mod 101$] e trabalhando bottom-up, temos:

latexmath:[$2^1 \mod 101 = 2 \mod 101 = 2$] +
latexmath:[$2^2 \mod 101 = 4 \mod 101 = 4$] +
latexmath:[$2^3 \mod 101 = 2 \times (2^1)^2 \mod 101 = 8 \mod 101 = 8$] +
latexmath:[$2^6 \mod 101 = \cdots = 64$] +
latexmath:[$2^7 \mod 101 = \cdots = 27$] +
latexmath:[$2^{14} \mod 101 = \cdots = 22$] +
latexmath:[$2^{15} \mod 101 = \cdots = 44$] +
latexmath:[$2^{30} \mod 101 = \cdots = 17$] +
latexmath:[$2^{60} \mod 101 = 172 \mod 101 = \cdots = 87$].
====

.{zwsp}
====
Qual é o último dígito de 1234567890123456789 elevado a 1025?

{zwsp} +
*Solução:* A palavra ``dígito'' significa que a aritmética é a da base 10. Para sabermos o último dígito, só precisamos operar na aritmética de módulo 10, e a fórmula é latexmath:[$(a^b) \mod c = ((a \mod c)^b) \mod c$]. Aqui, latexmath:[$a = 1234567890123456789$], latexmath:[$b = 1025$]; latexmath:[$c =10$]. Temos latexmath:[$a \mod c$] é 9. Começamos a operar com este valor, e sempre aplicamos latexmath:[$\mod 10$] a cada multiplicação. Usando divida e conquiste, temos:

latexmath:[$a^2 \mod 10 = ((a \mod 10)(a \mod 10)) \mod 10 = 81 \mod 10 = 1$] +
latexmath:[$a^4 \mod 10 = ((a^2 \mod 10)(a^2 \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$a^8 \mod 10 = ((a^4 \mod 10)(a^4 \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$a^{16} \mod 10 = ((a^8 \mod 10)(a^8 \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$\cdots$] +
latexmath:[$a^{1024} \mod 10 = ((a^{512} \mod 10)(a^{512} \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$a^{1025} \mod 10 = ((a^1 \mod 10)(a^{1024} \mod 10)) \mod 10 = (9 \times 1) \mod 10 = 9$]
====

==== Atividades

.Compute 270 mod 1001 usando exponenciação modular. Mostre todas as etapas.

[[sec-7-5]]
=== Congruências 

NOTE: Além dos livros texto, às vezes inspiramo-nos no bom sumário do livro _Programming Challenges (Skiena, Revilla)_ http://www.inf.ufrgs.br/~comba/inf1056-files/class01.pdf]

Sejam dois inteiros latexmath:[$b$],latexmath:[$c$], e seja um natural latexmath:[$m$] (chamado de modulus). Se latexmath:[$b \mod m = c \mod m$] (ou, equivalentemente, se latexmath:[$b-c$] é divisível por latexmath:[$m$]), então escreve-se latexmath:[$b \equiv c (\mod m)$], que é lido ``b,c são congruentes módulo m''. (Às vezes o modulus latexmath:[$m$] é entendido pelo contexto e pode ser omitido, ficando apenas implícito, de modo que se escreve apenas  latexmath:[$b \equiv c$], tendo-se o cuidado de não se confundir latexmath:[$\equiv$] com o sinal de equivalência.)

Congruências são (``apenas'') uma notação alternativa para a aritmética modular, mas, mesmo assim, a notação é importante, pois nos faz pensar sobre o conjunto de números inteiros latexmath:[$b$]\'s com um mesmo resto, latexmath:[$r$], quando divididos por latexmath:[$m$], e nos dá equações para representar o conjunto.

Podemos ver latexmath:[$b \equiv c (\mod m)$] como a classe de equivalência (o conjunto) onde qualquer elemento arbitrariamente escolhido, latexmath:[$x$], satisfaz latexmath:[$x \mod m = b \mod m$] (também igual a latexmath:[$c \mod m$]), e a diferença entre dois quaisquer elementos latexmath:[$x$],latexmath:[$y$] do conjunto é um múltiplo de latexmath:[$m$]. 

.{zwsp}
====
Que inteiros latexmath:[$x$] satisfazem a congruência latexmath:[$x \equiv 3 (\mod 9)$]?

{zwsp} +
*Solução:* latexmath:[$\{\ldots ,-33,-24,-15,-6,3,12,21,30,39,48, \ldots\} = 9k + 3$], em que latexmath:[$k$] é um número inteiro qualquer.
====

.{zwsp}
====
Que inteiros latexmath:[$x$] satisfazem (latexmath:[$2x \equiv 3 (\mod 9)$]) e (latexmath:[$2x \equiv 3 (\mod 4)$])?

{zwsp} +
*Solução:* latexmath:[$\{6,15,24,33,42, \ldots \} \cap \{\} = \{\}$]
====

==== Operações Sobre Congruências 

*Adição e Subtração:* + 
Suponha que latexmath:[$a \equiv b (\mod n)$] e latexmath:[$c \equiv d (\mod n)$]. Então, latexmath:[$(a + c) \equiv (b + d) (\mod n)$]. Também, latexmath:[$(a – c) \equiv (b - d) (\mod n)$]. +
Por exemplo, suponha que eu sei que latexmath:[$4x \equiv 7 (\mod 9)$] e latexmath:[$3x \equiv 3 (\mod 9)$]. Então, latexmath:[$(4x - 3x) \equiv (7-3) (\mod 9)$]. Portanto, latexmath:[$x \equiv 4 (\mod 9)$].

*Multiplicação:* +
É evidente que latexmath:[$a \equiv b (\mod n)$] implica que latexmath:[$(a \cdot d) \equiv (b \cdot d) (\mod n)$], adicionando a congruência reduzida para si mesma, latexmath:[$d$] vezes. Na verdade, a multiplicação geral também é válida, ou seja, (latexmath:[$a \equiv b (\mod n)$]) e (latexmath:[$c \equiv d (\mod n)$]) implicam latexmath:[$(a \cdot c) \equiv (b \cdot d) (\mod n)$].

*Divisão:* +
No entanto, não podemos impensadamente cancelar fatores comuns de congruências. Note-se que latexmath:[$(6 \times 2) \equiv (6 \times 1) (\mod 3)$], mas claramente é falso que latexmath:[$2 \equiv 1 (\mod 3)$]. + 
Para ver o que o problema é, note que podemos redefinir divisão como multiplicação por uma inversa, então latexmath:[$x/y$] é equivalente a latexmath:[$x(y^{-1})$]. Assim, podemos calcular latexmath:[$a/b (\mod n)$] se podemos encontrar um inverso latexmath:[$b^{-1}$] tal que latexmath:[$b(b^{-1}) \equiv 1 (\mod n)$]. Este inverso nem sempre existe – tente encontrar uma solução (inteira, claro) para latexmath:[$(2 \cdot x) \equiv 1 (\mod 4)$]. +
Sim, _podemos_ simplificar uma congruência latexmath:[$(a \cdot d) \equiv (b \cdot d) \mod (d \cdot n)$] para uma latexmath:[$a \equiv b (\mod n)$], de modo que podemos dividir todos os três termos por um fator comum, se houver. Assim, latexmath:[$170 \equiv 30 (\mod 140)$] implica que latexmath:[$17 \equiv 3 (\mod 14)$]. No entanto (, dado latexmath:[$(a \cdot d) \equiv (b \cdot d) \mod (n),), a congruência latexmath:[$a \equiv b (\mod n)$] deve ser falsa (ou seja, não tem solução) se latexmath:[$mdc(a,n)$] não divide latexmath:[$b$].

==== Resolvendo Congruências Lineares

Uma congruência linear é uma equação da forma latexmath:[$(a \cdot x) \equiv b (\mod n)$]. Resolver essa equação significa identificar quais os valores de latexmath:[$x$] que a satisfazem.

Nem todas essas equações têm soluções. Vimos números inteiros que não têm inversos multiplicativos em relação a um dado módulo, o que significa que latexmath:[$(a \cdot x) \equiv 1 (\mod n)$] não tem uma solução. Na verdade, latexmath:[$(a \cdot x) \equiv 1 (\mod n)$] tem uma solução se e somente se o módulo e o multiplicador são relativamente primos, ou seja, latexmath:[$mdc(a,n) = 1$]. Podemos utilizar o algoritmo de Euclides para encontrar esta inversa através da solução para latexmath:[$a' \cdot x + n \cdot y' = mdc(a,n) = 1$]. Assim, latexmath:[$((a \cdot x) \equiv 1 (\mod n)) \rightarrow ((a \cdot x) \equiv (a \cdot x' + n \cdot y') (\mod n))$].

Claramente latexmath:[$(n \cdot y') \equiv 0 (\mod n)$], então na verdade este inverso é simplesmente o latexmath:[$x'$] do algoritmo de Euclides.

Em geral, existem três casos, dependendo da relação entre latexmath:[$a$], latexmath:[$b$], e latexmath:[$n$]:

* latexmath:[$mdc(a,b,n) > 1$]. Então, podemos dividir todos os três termos por este divisor para obter uma congruência equivalente. Isso nos dá um única solução latexmath:[$\mod$] a nova base; ou; equivalentemente; latexmath:[$mdc(a,b,n)$] soluções (latexmath:[$\mod n$]).
* latexmath:[$mdc(a,n)$] não divide latexmath:[$b$]. Então, como descrito acima, a congruência pode não ter nenhuma solução.
* latexmath:[$mdc(a,n) = 1$]. Então há uma solução (latexmath:[$\mod n$]). Além disso, latexmath:[$x = (a^{-1}) \cdot b$] funciona, uma vez que latexmath:[$(aa^{-1}b) \equiv b (\mod n)$]. Como mostrado acima, este inverso existe e pode ser encontrado utilizando o algoritmo de Euclides.

.{zwsp}
====
Resolva o seguinte _sistema de congruências simultâneas_, onde os módulos são iguais: +
latexmath:[$4a + b \equiv 17 (\mod 26)$] +
latexmath:[$19a + b \equiv 3 (\mod 26)$] 

{zwsp} +
Solução:*

Resolva as equações normalmente - você vai acabar com

[latexmath]
++++
\[15a \equiv -14 \equiv 12(\mod 26)\]
++++

Para resolver latexmath:[$15a  \equiv  12 (\mod 26)$], você divide tudo por 3 e obtém latexmath:[$5a \equiv 4 (\mod 26)$]. Agora, use força bruta para achar um múltiplo de 5 que lhe dê 4 em módulo 26 (eu tenho certeza que há uma maneira mais elegante, mas fico satisfeito com a maneira que se segue). Este múltiplo é 6, veja: latexmath:[$5 \cdot 6 = 30  \equiv  4 \mod 26$]. Assim, latexmath:[$a \equiv 6$].

Aplicando isso na 1ª equação, latexmath:[$4a + b = 17$], você obtém latexmath:[$b = 17-24 = -7 = 19 \mod 26$].

Juntando tudo, as respostas são: latexmath:[$a \equiv 6 (\mod 26)$], e latexmath:[$b \equiv 19 (\mod 26)$].
====

O *Teorema Chinês do Resto* (que não vamos cobrar em exames) nos dá uma ferramenta para trabalhar com sistemas de congruências sobre módulos diferentes. Suponha que existe um inteiro latexmath:[$x$] tal que latexmath:[$x \equiv a_1 (\mod m_1)$] e latexmath:[$x \equiv a_2 (\mod m_2)$]. Então latexmath:[$x$] é unicamente determinado (latexmath:[$\mod m_1 m_2)$] se latexmath:[$m_1$] e latexmath:[$m_2$] são relativamente primos. Para encontrar esse latexmath:[$x$], e, assim, resolver o sistema de duas congruências, começamos por resolver as congruências lineares latexmath:[$m_2 b_1 \equiv 1 (\mod m_1)$] e latexmath:[$m_1 b_1 \equiv 1 (\mod m_2)$] para encontrar latexmath:[$b_1$] e latexmath:[$b_2$], respectivamente.
 
Em seguida, pode ser facilmente verificado que latexmath:[$x = a_1 b_1 m_2 + a_2 b_2 m_1$] é uma solução para ambas as congruências originais. 

Além disso, o teorema prontamente se estende aos sistemas de um número arbitrário de congruências cujos módulos são todos pares relativamente primos, analisados par a par.

Se latexmath:[$m_k$] é um inteiro positivo e latexmath:[$mdc(m_i,m_j) = 1 (i \not= j)$](números primos entre si) então o sistema de congruências lineares:

latexmath:[$x \equiv a_1 (\mod \cdot m_1)$] +
latexmath:[$x \equiv a_2 (\mod \cdot m_2)$] +
latexmath:[$x \equiv a_3 (\mod \cdot m_3)$] +
latexmath:[$x \equiv a_4 (\mod \cdot m_4)$] +
latexmath:[$x \equiv a_5 (\mod \cdot m_5)$] +
latexmath:[$x \equiv a_6 (\mod \cdot m_6)$] +
latexmath:[$\cdots$] +
latexmath:[$x \equiv a_{n-1} (\mod \cdot m_{n-1})$] +
latexmath:[$x \equiv a_n (\mod \cdot m_n)$] +
Tem uma única solução: latexmath:[$x \equiv X (\mod m) m = m_1 m_2 m_3 \cdot m_{n-1} m_n$] 

O valor de latexmath:[$X$] pode ser encontrado utilizando-se o Teorema Chinês do Resto: +
latexmath:[$X= a_1 \cdot M_1 \cdot x_1 + a_2 \cdot M_2 \cdot x_2+ a_3 \cdot M_3 \cdot x_3+ a_4 \cdot M_4 \cdot x_4 + \cdots + a_n \cdot M_n \cdot x_n$] +
latexmath:[$M_a$] é o produto de todos os latexmath:[$m_k$] com exceção de latexmath:[$m_a$] (Exemplo: latexmath:[$M_1=m_2 \cdot m_3 \cdot \cdots \cdot m_n$])
latexmath:[$x_a$] é o número que torna latexmath:[$M_a \cdot x_a \equiv 1(\mod m_a)$]

[[sec-7-5-3]]
==== Equações Diofantinas

*Equações Diofantinas* (no exame, no máximo, no máximo, poderá haver alguma pergunta conceitual do tipo ``que significa... qual a ideia básica..., etc.'') são fórmulas em que as variáveis são restritas a números inteiros.

Por exemplo, o último teorema de Fermat refere-se a respostas para a equação latexmath:[$a^n + b^n = c^n$]. Resolver tal equação para os números reais não é grande coisa. É somente se todas as variáveis forem restritas a números inteiros que o problema se torna difícil.
Equações diofantinas são difíceis de trabalhar, pois a divisão não é uma operação de rotina com fórmulas para inteiros. No entanto, existem algumas classes de equações diofantinas que são conhecidos como sendo solúveis e estas tendem a surgir frequentemente.

A classe mais importante é a de equações lineares diofantinas da forma latexmath:[$ax - ny = b$], em que latexmath:[$x$], latexmath:[$y$] são variáveis inteiras, e latexmath:[$a$], latexmath:[$b$], latexmath:[$n$] são constantes inteiras. 

Pode ser prontamente demonstrado que essas equações são equivalentes à solução da congruência latexmath:[$ax \equiv b (\mod n)$] e, consequentemente, podem ser resolvidas usando as técnicas da seção anterior. 

Análises diofantinas mais avançadas estão além do escopo deste pequeno livro de introdução à Matemática Discreta. Se você quiser ver mais sobre análises diofantinas, comece pelas referências- padrão na Teoria dos Números, tais como (Niven e Zuckerman 1991), (Hardy e Wright 1979), etc., depois siga para as referências adicionais que dão sobre tais análises. Depois, peça de um especialista referências mais novas e específicas.

==== Atividades

. Faça as tábuas de adição e multiplicação para latexmath:[$Z_6$]. (latexmath:[$Z_m$] é o conjunto das classes dos restos módulo latexmath:[$m$], isto é, latexmath:[$\{\bar{0},\bar{1}, \ldots ,\bar{m}\}$], onde \bar{y} é a classe latexmath:[$\{x \in \mathbb{Z} | x \equiv y (\mod m)\}$]).
. Encontre o resto da divisão de latexmath:[$7^{256}$] por 15.
. Estabeleça a validade do critério para decidir se um inteiro é divisível por 3 (três) que você aprendeu na quarta série do ensino fundamental.
. Mostre a validade da ``prova dos nove'' que foi ensinada na segunda série do ensino fundamental. 
. Considere a seguinte aﬁrmativa sobre um natural latexmath:[$n$]: ``Um natural é divisível por latexmath:[$n$] se-e-somente-se a soma de seus dígitos, quando representado na base 10, é divisível por latexmath:[$n$]''. Para que naturais latexmath:[$n$] esta aﬁrmativa é verdadeira?
. Liste todos os divisores de zero de latexmath:[$Z_{45}$].
. Encontre todos os valores inteiros de latexmath:[$X$] que satisfazem cada uma das congruências abaixo: +
[width="100%",cols="<,<,<",frame="none",grid="none"]
|====
|a) latexmath:[$5X \equiv 3 (\mod 9)$];
|b) latexmath:[$6X \equiv 3 (\mod 9)$];
|c) latexmath:[$6X \equiv 4 (\mod 9)$];
|d) latexmath:[$2X + 3 \equiv 5X = 9 (\mod 13)$];
|e) latexmath:[$X^2 \equiv 1 (\mod 16)$].
|
|====

=== Triplas Pitagóricas

*Triplas Pitagóricas* são três inteiros positivos latexmath:[$a,b,c$] tais que latexmath:[$a^2 + b^2 = c^2$].

Infinitas Triplas Pitagóricas podem ser obtidas a partir de uma, cada vez multiplicando-se esta por uma diferente constante positiva. Por isso, estamos interessados em Triplas Pitagóricas *Primitivas*, onde latexmath:[$a,b,c$] não têm fator comum (são primos entre si).

*Teorema das Triplas Pitagóricas:* Cada Tripla Pitagórica Primitiva latexmath:[$(a,b,c)$] (assume-se que latexmath:[$a$] é ímpar, latexmath:[$b$] é par, latexmath:[$a$] e latexmath:[$b$] são primos entre si) pode ser encontrada assim: +
latexmath:[$a = s \cdot t$], onde latexmath:[$s > t \geq 1$] são escolhidos como inteiros ímpares sem fatores comuns +
latexmath:[$b = \frac{(s^2 – t^2)}{2}$] (note que, assim, latexmath:[$b$] será par) +
latexmath:[$c = \frac{(s^2 + t^2)}{2}$]

NOTE: Ver prova na seção 2 de http://ssli.ee.washington.edu/~halloj3/math_sen_synth07.pdf. Mas o artigo em http://mathworld.wolfram.com/PythagoreanTriple.html é mais específico sobre o assunto.

.{zwsp}
====
Se você escolher latexmath:[$s = 3$]; latexmath:[$t = 1$]; achará a Tripla Pitagórica Primitiva que tem  latexmath:[$a = s \cdot t = 3 \cdot 1 = 3$]; latexmath:[$b = \frac{(9-1)}{2} = 4$]; latexmath:[$c = \frac{(9+1)}{2} = 5$].
====

.{zwsp}
====
Se você escolher latexmath:[$s = 9$]; latexmath:[$t = 7$]; achará a T.P. Primitiva que tem latexmath:[$a = s \cdot t = 9 \cdpt 7 = 63$]; latexmath:[$b = \frac{(s \cdot s – t \cdot t)}{2} = \frac{(81-49)}{2} = 16$]; latexmath:[$c = \frac{(s \cdot s + t \cdot t)}{2} = \frac{(81+49)}{2} = 65$].
====

.{zwsp}
====
Se você escolher latexmath:[$s = 5$]; latexmath:[$t = 3$]; achará a T.P. Primitiva que tem latexmath:[$a = s \cdot t = 15$]; latexmath:[$b = 8$]; latexmath:[$c = 17$].
====

.{zwsp}
====
latexmath:[$r = 2, s = 1, (a,b,c) = (3,4,5)$].

latexmath:[$r = 3, s = 2, (a,b,c) = (5,12,13)$].

latexmath:[$r = 4, s = 1, (a,b,c) = (15,8,17)$].

latexmath:[$r = 4, s = 3, (a,b,c) = (7,24,25)$].

latexmath:[$r = 5, s = 2, (a,b,c) = (21,20,29)$].

latexmath:[$r = 5, s = 4, (a,b,c) = (9,40,41)$].

latexmath:[$r = 99, s = 62, (a,b,c) = (5957,12276,13645$)].
====

[[Ex-5]]
.{zwsp}
====
Triplas Pitagóricas são formadas por 3 inteiros latexmath:[$(a,b,c)$] tais que latexmath:[$a^2 + b^2 = c^2$]. Estamos interessados somente nas Triplas Pitagóricas Primitivas, onde latexmath:[$a,b,c$] não têm nenhum divisor em comum (são primos entre si). Prove que ou latexmath:[$a$] ou latexmath:[$b$] é ímpar e o outro é o par, e que latexmath:[$c$] é sempre impar. 

{zwsp} +
*Solução:* 

* latexmath:[$a$] e latexmath:[$b$] não podem, simultaneamente, ser par: se o fossem, latexmath:[$c$] também seria par. Isto significa que latexmath:[$a, b, c$] e teriam um fator comum de 2, e assim latexmath:[$(a, b, c)$] não seria uma T.P. Primitiva. Portanto, latexmath:[$a$] e latexmath:[$b$] não podem, simultaneamente, ser par.
* latexmath:[$a$] e latexmath:[$b$] não podem, simultaneamente, ser ímpar: Se o fossem, então latexmath:[$c$] seria par. Isto significa que latexmath:[$a = 2x + 1$], latexmath:[$b = 2y + 1$], e latexmath:[$c = 2z$], para alguns números latexmath:[$x, y, \mbox{ e } z$]. Substitua latexmath:[$a = 2x + 1$],latexmath:[$ b = 2a + 1$], e latexmath:[$c = 2z$] na equação latexmath:[$a^2 + b^2 = c^2$] e simplifique até obter latexmath:[$2x^2 + 2x + 2y^2 + 2y + 1 = 2z^2$]. O lado esquerdo é ímpar e o lado direito é par (portanto a equação é falsa), de modo que latexmath:[$a$] e latexmath:[$b$] não podem ser simultaneamente ímpar.
* latexmath:[$c$] é ímpar: se um elemento do par latexmath:[$(a,b)$] é par e o outro é ímpar, então a soma de seus quadrados é ímpar.

Portanto, latexmath:[$c$] é ímpar.
====

.{zwsp}
====
Triplas Pitagóricas são formadas por 3 inteiros positivos latexmath:[$(a,b,c)$] tais que latexmath:[$a^2 + b^2 = c^2$]. Estamos interessados somente nas Triplas Pitagóricas Primitivas, onde latexmath:[$(a,b,c)$] não têm nenhum divisor em comum (são primos entre si). Prove que latexmath:[$a$] e latexmath:[$b$] não podem ambos ser par, nem podem ambos ser ímpar.

{zwsp} +
*Solução:*

Ora, este é o mesmo <<Ex-5>>, mas vamos conceder em resolvê-lo de novo, com palavras um pouquinho diferentes, talvez lhe ajude a compreender melhor algumas coisas de provas:

* latexmath:[$a$] e latexmath:[$b$] não podem ambos ser par, porque latexmath:[$a^2$] e latexmath:[$b^2$] seriam pares, portanto a soma deles (latexmath:[$c^2$]) teria que ser um par, portanto latexmath:[$a, b, c$] seriam divisíveis por 2 e a tripla não seria primitiva.
* latexmath:[$a$] e latexmath:[$b$] não podem ambos ser ímpar, porque, então, os seus quadrados deixariam resto 1 quando divididos por 4 (porque latexmath:[$(2n+1)^2 = 4n^2 + 2 \cdot 2n+1$]), então latexmath:[$a^2 + b^2$] deixaria resto 2 quando dividido por 4. Isto implicaria que latexmath:[$c$] é par, assim latexmath:[$c^2$] é divisível por 4. Esta é uma contradição: latexmath:[$c^2$] não pode deixar restos de ambos 0 e 2 quando dividido por 4. Assim não ambos de latexmath:[$a$] e latexmath:[$b$] são ímpar. 
====

[[Ex-Teo]]
.{zwsp}
====
Prove que, *em cada T.P. Primitiva, um dos números é divisível por 3, um dos números é divisível por 4, e um dos números é divisível por 5.*

{zwsp} +
*Solução:*

Reescrevamos o Teorema das Triplas Pitagóricas Primitivas: +
Se latexmath:[$(x,y,z)$] é uma T.P.Primitiva, então sejam os inteiros latexmath:[$a > b \geq 1$] escolhidos: 1) como primos entre si; 2) que não são, ambos, ímpares; 3) que satisfaçam: +
latexmath:[$x = 2ab$] +
latexmath:[$y = a^2 - b^2$] +
latexmath:[$z = a^2 + b^2$] 

1) Provemos que latexmath:[$x = 2ab$] é divisível por 4. +
latexmath:[$a$] e latexmath:[$b$] podem ser (ambos pares) XOR (um par e outro ímpar). (Se eles fossem ambos ímpares, isto contradizeria uma de nossas suposições originais.) Em qualquer caso, um deles tem que ser par. Digamos que o número par é o latexmath:[$a$]. Assim, latexmath:[$a = 2n$], para algum número inteiro latexmath:[$n$], e  latexmath:[$x = 2ab = 2 (2n)b = 4nb$] é divisível por 4. O mesmo vale se latexmath:[$b$] é par.

2) Provemos que um número (latexmath:[$x$] ou latexmath:[$y$] ou latexmath:[$c$]) é sempre divisível por 3. +
Qualquer inteiro latexmath:[$n$] pode ser escrito na forma:  latexmath:[$n \equiv p (\mod 3)$], onde latexmath:[$p$] é 0, 1 ou 2. +
Se latexmath:[$n \equiv 0 (\mod 3)$], então latexmath:[$n_2 \equiv 0 (\mod 3) \cdot 0 (\mod 3) \equiv 0 (\mod 3)$] +
Se latexmath:[$n \equiv 1 (\mod 3)$], então latexmath:[$n_2 \equiv 1 (\mod 3) \cdot 1 (\mod 3) \equiv 1 (\mod 3)$] +
Se latexmath:[$n \equiv 2 (\mod 3)$], então latexmath:[$n_2 \equiv 2 (\mod 3) \cdot 2 (\mod 3) \equiv 1 (\mod 3)$] +
Então, *todo inteiro elevado a 2 é 0 ou é 1, tudo isso (mod 3)*. +
Se algum de latexmath:[$x$], latexmath:[$y$] ou latexmath:[$z$] é igual a latexmath:[$0 (\mod 3)$], acabamos aprova, porque então eles serão divisíveis por 3. + 
Suponha que nenhum de latexmath:[$x$], latexmath:[$y$] ou latexmath:[$z$] é igual a latexmath:[$0 (\mod 3)$]. Sabemos que latexmath:[$x^2 + y^2 = z^2$] e, desde que latexmath:[$x$] e latexmath:[$y$] são iguais a latexmath:[$1 (\mod 3)$] ou latexmath:[$2 (\mod 3)$], latexmath:[$z^2 \equiv 1 (\mod 3) + 1 (\mod 3) \equiv 2 (\mod 3)$]. +
Mas isso contradiz com o que foi provado e sublinhado, pouco acima (``todo inteiro elevado a 2 é 0 ou é 1, tudo isso (latexmath:[$\mod 3$])''). +
Portanto, um dos três (latexmath:[$x$] ou latexmath:[$y$] ou latexmath:[$c$]) tem que ser divisível por 3.

3) Provemos que um número (latexmath:[$x$] ou latexmath:[$y$] ou latexmath:[$c$]) é um múltiplo de 5 +
Mais uma vez o mesmo tipo de argumento se mantém. Considere o que acontece quando elevamos inteiros ao quadrado, em latexmath:[$\mod 5$]. +
Digamos que latexmath:[$m = q (\mod 5)$]. Então: +
Se latexmath:[$q = 0$], então latexmath:[$m^2 = 0 (\mod 5)$] +
Se latexmath:[$q = 1$], então latexmath:[$m^2 = 1 (\mod 5)$] +
Se latexmath:[$q = 2$], então latexmath:[$m^2 = 4 (\mod 5)$] +
Se latexmath:[$q = 3$], então latexmath:[$m^2 = 4 (\mod 5)$] +
Se latexmath:[$q = 4$], então latexmath:[$m^2 = 1 (\mod 5)$] +
Assim, todo inteiro elevado a 2 é 0 ou é latexmath:[$1n$] ou é 4, tudo isso (latexmath:[$mod 5$]). +
Novamente, considere os nossos números latexmath:[$x$], latexmath:[$y$], e latexmath:[$z$]. +
Se algum deles é divisível por 5, então terminamos a prova. +
Suponha que nenhum deles é divisível por 5. A equação latexmath:[$x^2 + y^2 = z^2$] nos diz que latexmath:[$z^2$] é uma de três coisas: 0 (isto é, latexmath:[$1 +4$]), ou 2 (isto é, latexmath:[$1 +1$]), ou 3 (isto é, latexmath:[$4 + 4$]), tudo isso (latexmath:[$\mod 5$]). Uma vez que um número inteiro elevado ao quadrado nunca pode ser 2 ou 3 (latexmath:[$\mod 5$]), então latexmath:[$z^2$] deve ser latexmath:[$0 (\mod 5)$], o que significa que latexmath:[$z$] é divisível por 5. Isto contradiz a nossa suposição original. +
Por isso, um dos três números tem que ser divisível por 5.
====

.{zwsp}
====
À luz do teorema acima (<<Ex-Teo>>: ``um dos números é divisível por 3, outro dos números é divisível por 4, e um outro dos números é divisível por 5.''), como você explica que latexmath:[$a = 15$]; latexmath:[$b = 8$]; latexmath:[$c = 17$] formam uma T.P. (pois latexmath:[$a^2 + b^2 = 15^2 + 8^2 = 225+ 64= 289 = 17^2$] ), mas 17 não é divisível por 3, nem por 4, nem por 5?

{zwsp} +
*Solução:* A citação do teorema está errada. O correto somente diz ``um dos números é divisível por 3, um dos números é divisível por 4, e um dos números é divisível por 5.'' Não diz que esses números são distintos. 15 é divisível por 3, 8 é divisível por 4, e 15 é divisível por 5.
====

=== Recapitulando

Parabéns! Você concluiu o capítulo 7 e, se foi disciplinado e realmente ``suou'' estudando 4 a 8 h cada semana, deve ter aprendido muitas coisas da parte básica da ``Teoria dos Números'' que lhe serão indispensáveis ou muito úteis em todo o resto do curso e sua vida profissional: Conceitos e propriedades dos primos, como testar a primalidade de um natural exatamente (se for pequeno) e com altíssima probabilidade e eficiência (se for enorme); divisibilidade e como achar latexmath:[$mdc$] e latexmath:[$mmc$] eficientemente; aritmética modular e sua aplicação à rápida exponenciação modular, vital para muita coisa da criptografia; congruências; triplas pitagóricas; as mais simples equações diofantinas e seus sistemas de equações. 

Agora, um esforço final: invista pesado na próxima semana, revisando todas as 7 unidades, particularmente todos os exercícios que você já fez para nota e todos os exercícios de auto-avaliação (sem nota) preparatórios para o exame final, depois confiantemente se submeta à prova final. Você pode ter pleno sucesso, só depende de você fazer este esforço final. 

Desejamos-lhe todo sucesso nas provas finais desta disciplina, e na continuação do curso, e em toda sua vida profissional!

////
Sempre termine os arquivos com uma linha em branco.
////