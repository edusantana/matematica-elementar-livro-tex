
















=== Divisibilidade

latexmath:[$b$] *divide* latexmath:[$a$] (denotado latexmath:[$b \vert a$]) se latexmath:[$bk = a$], para algum inteiro latexmath:[$k$]. latexmath:[$b$] é chamado de um *divisor* de latexmath:[$a$], latexmath:[$a$] é chamado de um *múltiplo* de latexmath:[$b$].

*Ache todos os divisores de um dado inteiro latexmath:[$x$]:*
 
A partir do Teorema Fundamental da Aritmética, sabemos que latexmath:[$x$] é unicamente representado pelo produto de seus fatores primos. (
use http://primes.utm.edu/lists/small/10000.txt.) Cada divisor é o produto de algum subconjunto desses fatores primos. Tais subconjuntos 
podem ser construídos usando técnicas de backtracking, assim, por exemplo: latexmath:[$165 = 3 \times 5 \times 11$]. Seus divisores são 
1,3,5,11,15,33,55,165, mas devemos ter cuidado com fatores primos duplicados. Por exemplo, a fatoração de 12 em primos tem três termos (2, 
2, e 3), e poderia parecer que 12 tem latexmath:[$2^3 = 8$] divisores (correspondente ao conjunto potência, o conjunto vazio correspondente 
ao divisor 1), mas 12 tem apenas 6 divisores (1, 2, 2, 3, 4, 6, 12) (backtracking mal feito contaria latexmath:[$2 \times 2$] de duas 
maneiras, e contaria o resultado de latexmath:[$2 \times 3$] como diferente do resultado de latexmath:[$3 \times 2$], resultando em 
latexmath:[$\{1,2,2,3,2,2,3,4,6,6,12\}$]).

==== Máximo Divisor Comum (latexmath:[$mdc$]) (Greatest Common Divisor - latexmath:[$gcd$])

O maior divisor comum de dois ou mais números é chamado de máximo divisor comum (latexmath:[$mdc$]) desses números. 

*Propriedades:*

* Cada divisor comum de latexmath:[$a$] e latexmath:[$b$] é um divisor de latexmath:[$mdc(a,b)$].
* latexmath:[$mdc(a,b)$], onde latexmath:[$a$] e latexmath:[$b$] não são ambos zero, pode ser definido, alternativamente e equivalentemente,
 como o menor número inteiro positivo latexmath:[$d$] que pode ser escrito da forma latexmath:[$d = ap+bq$], onde latexmath:[$p$] e 
 latexmath:[$q$] são números inteiros . Esta expressão é denominada *identidade de Bézout*. Números latexmath:[$p$] e latexmath:[$q$] como 
 este pode ser calculados com o algoritmo estendido de Euclides.
* latexmath:[$mdc(a,0) = \vert a \vert$], para latexmath:[$a \not= 0$], uma vez que qualquer número é um divisor de 0, e o maior divisor de latexmath:[$a$] é latexmath:[$|a|$]. Isto é usado geralmente como o caso base no algoritmo de Euclides.
* latexmath:[$mdc(x,x) = x$] (Idempotência)
* Se latexmath:[$a$] divide o produto latexmath:[$b \cdot c], e latexmath:[$mdc(a,b) = d$], então latexmath:[$a/d$] divide latexmath:[$c$].
* Se latexmath:[$m$] é um inteiro não negativo, então latexmath:[$mdc(m \cdot a, m \cdot b) = m \cdot mdc(a,b)$].
* Se latexmath:[$m$] é um número inteiro qualquer, então latexmath:[$mdc(a + m \cdot b, b) = mdc(a,b)$].
* Se latexmath:[$m$] é um não nulo divisor comum de latexmath:[$a$] e latexmath:[$b$], então, latexmath:[$mdc(a/m, b/m) = mdc(a,b)/m$].
* O latexmath:[$mdc$] é uma *função multiplicativa* no seguinte sentido: se latexmath:[$a_1$] e latexmath:[$a_2$] são relativamente primos, então latexmath:[$mdc(a_1 \cdot a_2,b) = mdc(a_1,b) \cdot mdc(a_2,b)$].
* O latexmath:[$mdc$] é uma *função comutativa*: latexmath:[$mdc(a,b) = mdc(b,a)$].
* O latexmath:[$mdc$] é uma *função associativa*: latexmath:[$mdc(a, mdc(b,c)) = mdc(mdc(a,b), c)$].
* O latexmath:[$mdc$] de três números pode ser calculado como latexmath:[$mdc(a, b, c) = mdc(mdc(a,b),c)$], ou, de algum modo diferente, aplicando comutatividade e associatividade. Isso pode ser estendido a qualquer número de números.
* latexmath:[$mdc(a, b)$], está estreitamente relacionada com o mínimo múltiplo comum latexmath:[$mmc(a, b)$], temos: +
[latexmath]
++++
\[mdc(a,b) \cdot mmc(a, b) = a \cdot b\]
++++ +
Esta fórmula é muitas vezes usada para computar mínimo múltiplos comuns: primeiro se calcula a latexmath:[$mdc$] com o algoritmo de Euclides, e então se divide o produto dos números indicados por seu latexmath:[$mdc$].
* As seguintes versões da distributividade são verdadeiras:
**latexmath:[$mdc(a, mmc(b,c)) = mmc(mdc(a,b), mdc(a,c))$];
**latexmath:[$mmc(a, mdc(b,c)) = mdc(mmc(a,b), mmc(a,c))$].
* É útil se definir latexmath:[$mdc(0, 0) = 0$] e latexmath:[$mmc(0,0) = 0$], porque então os números naturais tornam-se um reticulado distributivo completo com latexmath:[$mdc$] como operação supremo (também chamada de ``join'', mesmo símbolo de ``or'') e latexmath:[$mmc$] como operação ínfimo (também chamada de ``meet'', mesmo símbolo de ``and''). 

*Primeiro método*, simples-direto-ineficiente, *de calcular latexmath:[$mdc$] de dois naturais:* 

Suponhamos que os números são latexmath:[$a = 126$] e latexmath:[$b = 420$]; +
Ache todos os divisores do menor dos números (latexmath:[$a = 126$]. Fatorando em primos ( http://primes.utm.edu/lists/small/10000.txt. ), 
latexmath:[$a= 2 \times 3 \times 3 \times 7$]; achando os produtos das combinações distintas deles, os divisores de latexmath:[$a$] são, 
ordenados crescentemente latexmath:[$\{1,2,3,6,7,9,14,18,21,42\}$]); +
Depois, em ordem decrescente, teste cada um deles até achar o maior deles que divida o outro número. (tente 42 e obterá sucesso.)

Ou, somente muito pouco diferente:

Suponhamos que os números são latexmath:[$a = 126$] e latexmath:[$b = 420$]; +
Decomponha cada um em seus fatores primos (use http://primes.utm.edu/lists/small/10000.txt ): latexmath:[$126 = 2^1 \times 3^2 \times 5^0 \times 7^1$]; latexmath:[$420 = 2^2 \times 3^1 \times 5^1 \times 7^1$]. +
O resultado será o produto de cada fator que aparece _em comum_ na fatoração de latexmath:[$a$] e de latexmath:[$b$], tomado com seu _menor_ expoente latexmath:[$2^1 \times 3^1 \times 5^0 \times 7^1 = 42$]. 

Outro exemplo (vou realçar os quocientes quando se aplicarem a todos os números): latexmath:[$mdc(70,90,120)$] 

[width="20%",cols="2a>,1a<", frame="none"]
|====
|`70  90  120
35  45  60 
35  45  30 
35  45  15 
35  15  5  
35  5   5  
7   1   1  
1   1   1  `
|`*2*
2
2
3
3
*5*
7`
|====
 
Ao final, multiplicamos somente os quocientes realçados.

*Algoritmo de Euclides* (1o algoritmo interessante em toda a História, que ``quebrou barreiras'', muito mais eficiente (latexmath:[$O(\log{n})$]) que todos os rivais) (é o avô de todos os algoritmos: tem mais de 2300 anos e não existe melhor): 

Baseado em 2 propriedades (prove-as em casa?):

* Se latexmath:[$b|a$], então latexmath:[$mdc(a,b) = b$].
* Se latexmath:[$a = bt + r$] para inteiros latexmath:[$t, r$], então latexmath:[$mdc(a,b) = mdc(b, r)$].

_Aprendemos no Ensino Fundamental:_ 

[quote]
mdc(maior, menor) := if menor = 0 then maior else mdc(menor, resto da divisão inteira maior/menor )

[width = "25%", cols="^,^,^,^"]
|====
|-   |1   |9    |-
|420 |378 |*42* |...0
|378 |378 |...  |...
|42  |0   |...  |...
|====

`Quocientes ArguEsq divinteira ArguAbaixo (primeira célula vazia)	
Argumentos (inicialmente {maior, menor} )
Multiplicação ArguDir x QuocDir 
Resto = ArguAcima - MultiplicaçãoAcima (transferir para ser ArguDir)`

Outro exemplo:

[width = "35%", cols="^,^,^,^,^,^,^"]
|====
|-   |5  |4 |1 |1 |2   |
|120 |23 |5 |3 |2 |*1* |0
|115 |20 |3 |2 |2 |    |
|5   |3  |2 |1 |0 |    |
|====

`Quocientes ArguEsq divinteira ArguAbaixo (primeira célula vazia)
Argumentos (inicialmente {maior, menor} )
Multiplicação ArguDir x QuocDir 	
Resto = ArguAcima - MultiplicaçãoAcima (transferir para ser ArguDir)`		

*Algoritmo de Euclides iterativo:*

----
AlgoritmoDeEuclides(a: inteiro; b: inteiro): inteiro
variáveis
   divisor: inteiro
   dividendo: inteiro
   c: inteiro
início
   dividendo = a
   divisor = b
   enquanto resto(dividendo/divisor) ≠ 0
   início
      c = resto(dividendo/divisor)
      dividendo = divisor
      divisor = c
   fim-enquanto
   
   AlgoritmoDeEuclides = divisor
fim-função
----

*Algoritmo de Euclides recursivo:*

----
AlgoritmoDeEuclides(a: inteiro; b: inteiro): inteiro
início
   se b = 0 então
      AlgoritmoDeEuclides = a
   senão
      AlgoritmoDeEuclides = AlgoritmoDeEuclides(b,resto(a,b))
   fim-se
fim-função
----

*Implementação de Euclides em C* (cuidado para prever o caso p=q=0):

[source,c]
----
/* Find the gcd(p,q) and x,y such that p*x + q*y = gcd(p,q) */
long gcd(long p, long q, long *x, long *y)
{
  long x1,y1; /* previous coefficients */
  long g; /* value of gcd(p,q) */
  if (q > p) return(gcd(q,p,y,x));
  if (q == 0) {
    *x = 1;
    *y = 0;
    return(p);
  }
  g = gcd(q, p%q, &x1, &y1);
  *x = y1;
  *y = (x1 - floor(p/q)*y1);
  return(g);
}
----

*Algoritmo de Euclides estendido:*

Além de encontrar o máximo divisor comum de inteiros latexmath:[$a$], latexmath:[$b$], como o algoritmo de Euclides faz, também encontra números inteiros latexmath:[$x$], latexmath:[$y$] (um dos quais é tipicamente negativo) que satisfazem a *identidade de Bézout*
[latexmath]
++++
\[ax + by = mdc(a,b)\]
++++

Por exemplo:

latexmath:[$120 \times (-9) + 23 \times (47) = mdc(120,23)$]. Aqui, latexmath:[$a = 120$], latexmath:[$b = 23$], latexmath:[$x = -9$], latexmath:[$y = 47$]. Realmente, latexmath:[$-1080 + 1081 = 1 = mdc(120,23) = mdc(23,5) = mdc(4,3) = mdc(3,1) = 1$].

O algoritmo estendido de Euclides é particularmente útil quando latexmath:[$a$] e latexmath:[$b$] são *relativamente primos* (também chamados de *co-primos* e ditos serem *primos entre si*), (dois números latexmath:[$a$], latexmath:[$b$] são co-primos se o único fator comum entre eles é 1. 10 e 21 são co-primos, porque latexmath:[$10=5 \times 2 \times 1$] e latexmath:[$21=7 \times 3 \times 1$], e esses números só têm 1 como fator em comum) uma vez que (latexmath:[$x$] é o inverso multiplicativo de latexmath:[$a$]) latexmath:[$\mod{b}$], e (latexmath:[$y$] é o inverso multiplicativo de latexmath:[$b$]) latexmath:[$\mod{a}$].

latexmath:[$x$] é o inverso multiplicativo módulo latexmath:[$m$] de um inteiro latexmath:[$a$] (e pode ser escrito latexmath:[$a^{-1} \mod{m}) se (latexmath:[$ax  \equiv  1$]) latexmath:[$\mod{m}$].

Por exemplo, se latexmath:[$m =3$], então 2 é o inverso multiplicativo de 23, porque latexmath:[$(23 \times 2) \mod{3} = ((23 \mod{3}) \times (2 \mod{3})) \mod{3} = (2 \times 2) \mod{3} = 4 \mod{3} = 14].

No exemplo lá em cima, (-9 é o inverso multiplicativo de 120) latexmath:[$\mod{23}$], pois latexmath:[$(23-9)=14$] e (latexmath:[$14 \TIMES 120$]) latexmath:[$\mod{23} = \cdots = 1$]. (47 é o inverso multiplicativo de 23) latexmath:[$\mod{120}, pois (latexmath:[$47 \times 23$]) latexmath:[$\mod{120} = \cdots = 1$]

[latexmath]
++++
/[mdc(120,23) = 120 \times(-9) + 49 \times (23) = -1080 + 1081 = 1\]
++++

*Euclides Estendido, Algoritmo Recursivo:*

----
function extended_gcd(a, b)   // retorna um par [(x,y), de modo que ax + by = mdc(a,b)]
    if b = 0
        return (1, 0)
    else
        q := a divinteira b
        r := a – b*q 
        (s, t) := extended_gcd(b, r)
        return (t, s - q*t)
----

*Euclides Estendido, Código em C:*


[source,c]
----
#include <stdio.h>
#include <stdlib.h>

/* Aritmética modular é também considerada como o "algoritmo do relógio".

Ao extrair o modulo 12, como resposta possível pode-se ter números de 0 a 11. Nunca negativo, pois a ideia é de um relógio com 12 posições, sendo a primeira o zero e a última o 11.

Porém o operador de módulo do C (operador %) computa apenas o resto da divisão e gera números negativos. Em C:

-2 mod 12 = -2 (não está entre 0 e 11)
2 mod -12 = 2  (não está entre -11 e 0)

O C dizer que -2 mod 12 é -2 significa dizer que ele está a -2 de distância do final do relógio, ou seja, está em 10 (o início e também o final do relógio é o zero).

Dizer que 2 mod -12 significa um relógio ao contrário (0, -1, -2, -3, .. -11, andando no sentido anti-horário) e que o valor 2 está a 2 posições de distância do 0, ou seja,está em -10.

Nesta aritmética modular o resultado da operação PRECISA SER do mesmo sinal do divisor.

Observou-se que o operador de módulo do python (%) não tem este comportamento, calculando o módulo não negativo. A biblioteca bn.h do openssl possui ambos, tanto a função BN_mod que simplesmente retorna o resto da divisão (comportamento igual ao % do C) como a função BN_nnmod que calcula o módulo não negativo.

Nesta versão em C resolveu-se fazer uma pequena correção na resposta dada pelo operador de módulo, pois o algoritmo de Euclides precisa do módulo positivo.
*/
long mod(long a, long b)
{
    long r = a % b;

    /* Uma correção é necessária se r e b não forem do mesmo sinal */

    /* se r for negativo e b positivo, precisa corrigir */
    if ((r < 0) && (b > 0))
	return (b + r);

    /* Se r for positivo e b negativo, nova correção */
    if ((r > 0) && (b < 0))
	return (b + r);

    return (r);
}

long euclides_ext(long a, long b, long c)
{
    long r;
    r = mod(b, a);
    if (r == 0) {
	return (mod((c / a), (b / a)));	// retorna (c/a) % (b/a)
    }
    return ((euclides_ext(r, a, -c) * b + c) / (mod(a, b)));
}
int main(int argc, char *argv[])
{
    long p, q, e, qq, n, d;

    /* O objetivo desta implementação do algoritmo de Euclides estendido é o cálculo do valor do D da chave privada correspondente a Ke=(n,e) http://www.vivaolinux.com.br/artigo/Criptografia-assimetrica-com-o-RSA/ para isto são necessários fornecer o p, o q e o valor de e */
    if (argc != 4) {
	fprintf(stderr, "ERRO. faltou passar valor de p, q, e\n");
	fprintf(stderr, "Forma de uso:\n");
	fprintf(stderr, "\t%s p q e\n", argv[0]);
	return (1);
    }

    /* pegando os valores de p, q e n fornecidos como argumentos do main */
    p = atol(argv[1]);
    q = atol(argv[2]);
    e = atol(argv[3]);

    /* calculando o n */
    n = p * q;

    /* calculando o quociente de Euller, chamado aqui de qq */
    qq = (p - 1) * (q - 1);

    /* chamando a função que calcula o d. Ela retorna um número que case na expressão: (d*e) mod qq = X para que M^(d*e) mod N = M
       Tem-se o e e o qq. Para o RSA o X deve ser 1, pois d*e mod qq = 1
     */
    d = euclides_ext(e, qq, 1);

    printf("\nVALORES CALCULADOS:\n");
    printf("N  = %10li\nE  = %10li\nqq = %10li\nD  = %10li\n", n, e, qq, d);
    printf("\n*** Verifique com ***\n");
    printf("\techo \"(%li * %li) %% %li\"|bc\n\n", d, e, qq);
    printf("\t(deve resultar em 1)\n\n\n");
----

NOTE: Veja, em http://pt.wikibooks.org/wiki/Teoria_de_n%C3%BAmeros/Divisibilidade, úteis regras de divisibilidade por 2,3,4,5,6,7,8,9,10,11. Porque funcionam pode ser visto em http://webspace.ship.edu/msrenault/divisibility/StupidDivisibilityTricks.pdf ou suas referências.

//_

==== Mínimo Múltiplo Comum (latexmath:[$mmc$]) (Least Common Multiple, latexmath:[$lcm$])

O *mínimo múltiplo comum* (latexmath:[$mmc$]) de dois inteiros latexmath:[$a$], latexmath:[$b$] é o menor inteiro positivo que é múltiplo 
simultaneamente de latexmath:[$a$] e de latexmath:[$b$]. Se não existir tal inteiro positivo, por exemplo, se latexmath:[$a = 0$] ou 
latexmath:[$b = 0$], então definimos que latexmath:[$mmc(a, b) = 0$].

É evidente que latexmath:[$mmc(x, y) \geq max(x, y)$]. Do mesmo modo, uma vez que latexmath:[$x \cdot y$] é um múltiplo de ambos latexmath:[$x$] e latexmath:[$y$], então latexmath:[$mmc(x, y) \leq x \cdot y$]. A única maneira pela qual pode haver um múltiplo comum menor que latexmath:[$xy$] é se há algum fator não trivial (i.e., diferente de 0 e de 1) partilhado entre latexmath:[$x$] e latexmath:[$y$]. Esta observação, juntamente com o algoritmo de Euclides, oferece uma maneira eficiente para computar mínimo múltiplo comum: se nem latexmath:[$a$] nem latexmath:[$b$] são zero, o mínimo múltiplo comum pode ser computado usando o Algoritmo de Euclides (para latexmath:[$mdc$]):

[width="80%",cols="<,<",grid="none",frame="none"]
|====
|se nem latexmath:[$a=0$] nem latexmath:[$b=0$], então	|latexmath:[$mmc(a,b) = (a \cdot b) / mdc(a,b)$]
|senão, 					                            |latexmath:[$mmc(a,b) = 0$]
|====

Sempre use a regra ``cancelar antes de multiplicar'': latexmath:[$mmc (24000, 36000)$], simplificado dividindo por 12000, dá latexmath:[$12000 \times mmc(2,3) = 12000 \times 6 = 72000$].

Considerado como operação binária, o latexmath:[$mmc$] de dois inteiros positivos tem as propriedades:

* *Comutativa*: latexmath:[$mmc(a,b) = mmc(b,a)$]
* *Associativa:* latexmath:[$mmc(a,mmc(b,c)) = mmc(mmc(a,b),c)$]
* *É idempotente:* latexmath:[$mmc(a,a) = a$]
* *1 é o elemento neutro:* latexmath:[$mmc(a,1) = a$]
* E a multiplicação é distributiva com o latexmath:[$mmc$]: latexmath:[$a \times mmc(b, c) = mmc(ab, ac)$]

Mínimo múltiplo comum surge quando queremos calcular a periodicidade simultânea de dois distintos eventos periódicos. Quando é o próximo ano (após 2000) em que a eleição presidencial (que acontece a cada 4 anos) vai coincidir com o censo (que acontece a cada 10 anos)? Os eventos coincidem cada vinte anos, porque latexmath:[$mmc(4,10) = 20$].

_Aprendemos no Ensino Fundamental:_

Suponhamos que os números são latexmath:[$a = 126$] e latexmath:[$b = 420$]; +
Decomponha cada um em seus fatores primos (use http://primes.utm.edu/lists/small/10000.txt): latexmath:[$126 = 2^1 \times 3^2 \times 5^0 \times 7^1$]; latexmath:[$420 = 2^2 \times 3^1 \times 5^1 \times 7^1$]. +
O resultado será o produto de cada fator (não precisa ser em comum) tomado com seu maior expoente latexmath:[$2^2 \times 3^2 \times 5^1 \times 7^1 = 1260 = 42$].

Outro exemplo: latexmath:[$mmc(70,90,120)$]

[width="20%",cols="2a>,1a<", frame="none"]
|====
|`70  90  120
35  45  60 
35  45  30 
35  45  15 
35  15  5  
35  5   5  
7   1   1  
1   1   1  `
|`*2*
2
2
3
3
*5*
7`
|====
 
O latexmath:[$mmc$] é o produto de todos os fatores: latexmath:[$mmc(70,90,120) = 2^3 \times 3^2 \times 5 \times 7 = 2520$]


.(mdc):
====
Etapa por etapa (usando a fórmula recursiva ou a construindo a tabela) mostre qual é o máximo divisor comum (latexmath:[$mdc$]) de 11025 e 3872. Que mais pode você dizer sobre esses números?

.{zwsp} +
*Solução:* (vamos resolver de vários modos):

Como aprendemos mais ou menos aos 10 anos de idade, tudo à mão, sem calculadora:

[width="100%",cols="2<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<",frame="none",grid="none"]
|====
|Quociente      |        |        |2     |1	   |5    |1   |1  |4   |2   |1 |9   |2
|Números	    |*11025* |*3872*  |3281  |591  |326  |265 |61 |21  |19  |2 |*1* |	
|Multiplicações |-7744   |-3281   |-2955 |-326 |-265 |244 |42 |-19 |-18 |2 |    |		
|Restos         |3281    |591     |326   |265  |61   |21  |19 |2   |1   |0 |    |	
|====

Ou, depois que começamos a usar calculadora que tinha a função módulo:

[width="100%",cols="2<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<,1<",frame="none",grid="none"]
|====
|Números	                        |11025 |3872 |3281 |591 |326 |265 |61 |21 |19 |2 |*1*
|latexmath:[$NorOeste \mod{Norte}$] |      |3281 |591  |326 |265 |61  |21 |19 |2  |1 |0
|====

(por exemplo, na segunda célula da linha de baixo: latexmath:[$11025 mod 3872 = 3281$])

Doutro modo, usando a fórmula recursiva:

`mdc(Maior,Menor)	 = mdc(Menor, (Maior % Menor))
mdc (11025,3872)	= mdc (3872, (11025 % 3872) =
mdc(3872,3281)	    = mdc(3281, (3872 % 3281)) =
mdc(3281,591)	    = mdc(591, (3281 % 591)) =
mdc(591,326)	    = mdc(326, (591 % 326)) =
mdc(326,265)	    = mdc(265, (326 % 265)) =
mdc(265,61)		    = mdc(61, (265 % 61)) =
mdc(61,21)		    = mdc(21, (61 % 21)) =
mdc(21,19)		    = mdc(19, (21 % 19)) =
mdc(19,2)		    = mdc(2, (19 % 2)) =
mdc(2,1)		    = mdc(1, (2 % 1)) =
mdc(1,0)		    = 1`

Doutro modo, fatorando os números em fatores primos, depois tomando em menor expoente os fatores primos comuns aos dois números:

latexmath[$11025 = 3^2 \cdot 5^2 \cdot 7^2$] + 
latexmath[$3872 = 2^5 \cdot 11^2$] +
latexmath[$mdc(11025,3872) = 1$]
   
(note que, para enormes números cujas fatorações podem exigir tentativas de divisão por grande número de primos, o algoritmo de Euclides é o mais eficiente de todos os que vimos)
====

=== Aritmética Modular

Algumas vezes não estamos interessados no resultado completo de operações aritméticas sobre números ``quilométricos'', mas somente nela módulo alguma coisa. 

.{zwsp}
====
Hoje é domingo. Que dia da semana será daqui a 1 milhão de dias? Bem, latexmath[$1000000 \mod{7} = 1$], portanto cairá num domingo + 1, ou seja, numa segunda-feira. 

Quanto é ((número de 10 trilhões de dígitos) elevado a (número de 3000 dígitos)) módulo (número primo de 400 dígitos)?
====

*Propriedades da Aritmética Modular:*

* latexmath[$(x + y) \mod n = ((x \mod n) + (y \mod n)) \mod n$]
** Exemplo: latexmath[$(90012 + 80053) \mod 5 = ((90012 \mod 5) + (80053 \mod 5)) \mod 5 = (2 + 3) \mod 5 = 5 \mod 5 = 0$] (note que para calcularmos latexmath[$n \mod 5$] basta nos ocuparmos do último dígito de latexmath[$n$]). 
* latexmath[$(x - y) \mod n   =   ((x \mod n) - (y \mod n)) \mod n$]
** Exemplo: latexmath[$(90012 - 80053) \mod 100 = ((90012 \mod 100) - (80053 \mod 100)) \mod 100  = (12 – 53) \mod 100 = −41 \mod 100 = 59 \mod 100 = 59$]
* latexmath[$(xy) \mod n = ((x \mod n)(y \mod n)) \mod n$]
** Exemplo: latexmath[$((90012 \times 80053)) \mod 100 = ((90012 \mod 100) \times (80053 \mod 100)) \mod 100  = (12 \times 53) \mod 100 = 636 \mod 100 = 36$] (para divisão, ver abaixo, em <<sec-7-5>>).

*Aplicações da Aritmética Modular:*

* *1ª Aplicação:* Achar o último dígito — Qual é o último dígito de (longa expressão aritmética,por enquanto sem divisão, com grandes inteiros)?
* *2ª Aplicação:* Cálculos a Respeito de Calendários;
* *3ª Aplicação:* Exponenciação modular: Pela definição de potência, podemos calcular latexmath[$a^n$] assim: +
`function exposeq(a,n)
  r := a
  for i := 1 to n-1 do r := a*r
  return r` +
Mas isto é muito ruim pois, no pior caso, o número de multiplicações é assintoticamente proporcional a latexmath[$n$], isto é, é latexmath[$O(n)$].

Uma conhecida técnica geral para solução de problemas é a ``Divida e Conquiste'':

`Se o tamanho do problema é suficientemente pequeno, então resolva-o diretamente 
senão 
  divida-o em 2 ou mais subproblemas menores de tamanhos os mais iguais possíveis; 
  resolva-os; 
  retorne a apropriada junção dessas soluções dos subproblemas `
  
Usando a técnica de ``Divida e Conquiste'', a exponenciação modular fica bem mais eficiente:

----
function expoDC(a,n)            // recursivo
  if n = 1 then return a
  if par(n) then return(expoDC(a, n/2))^2
  return a * expoDC(a, n-1)
----

ou

----
function expoiter(a,n)		// tempo semelhante expoDC
  i := n; r := 1; x := a
  while i > 0 do
    if i ímpar(i) then r := r*x
  x := x^2
  i := i÷2		{divisão inteira}
  return r
----

Melhorou muito, pois o número de multiplicações caiu para latexmath:[$O(\log n)$]

Mas, em MUITAS aplicações, a base latexmath:[$a$] tem milhões de dígitos e temos que usar os lentos módulos de aritmética de precisão 
``infinita''  embutidos da biblioteca da linguagem (BigNum), e a potência latexmath:[$n$] tem milhares de dígitos, levaria séculos para 
fazer os cálculos; mas só precisamos do resultado módulo um número de algumas centenas ou milhares de dígitos, e tudo pode ser feito 
extraordinariamente mais rápido (em microsegundos?), usando aritmética modular.


==== Problema 374 do ACM Programming Contest (BigMod)

NOTE: No exame, no máximo, no máximo, poderá haver alguma pergunta conceitual do tipo ``que significa... qual a vantagem... qual a diferença... como funciona... qual a ideia básica...'' Não será pedido mais que isso: nem prova de corretude, nem prova de complexidade, etc. Mas a implementação seria um ótimo trabalho de casa depois de você ter dominado 2 disciplinas de programação.

Calcule +
[latexmath]
++++
\[R := B^P \mod M\]
++++

para valores enormes para latexmath:[$B$], latexmath:[$P$], e latexmath:[$M$], usando um algoritmo eficiente (sim, este programa tem uma restrição quanto ao tempo!)

latexmath:[$(a^b) \mod c = ((a \mod c)^b) \mod c $] (faça as multiplicações em aritmética modular) +
(ache um contra-exemplo e verá que é falso latexmath:[$(a^b) \mod c = ((a \mod c)^{(b \mod c)}) \mod c$])

Em Python:

[source, python]
----
def ExpoModularRec(BaseMdlada, Expo, Modulo):
  if Expo == 1:
    Resposta = BaseMdlada
  elif Expo == 0:
    Resposta = 1; # optei por fazer 0^0 = 1 e não 0
  elif BaseMdlada == 0:
    Resposta = 0
  elif BaseMdlada == 1:
    Resposta = 1
  elif Expo % 2 == 0:
    Aux = ExpoModularRec(BaseMdlada,(Expo/2), Modulo)
    Resposta = (Aux * Aux) % Modulo
  else: Resposta = (BaseMdlada * 
       ExpoModularRec(BaseMdlada, (Expo -1), Modulo)) % Modulo
  return Resposta
----

NOTE: 4ª Aplicação: Usando a 3ª aplicação (Exponenciação Modular) de Aritmética Modular, chegamos ao: *Algoritmo de criptografia RSA* (RSA Encryption Algorithm) - a nossa mensagem é criptografada por codificá-lo como um inteiro latexmath:[$m$], depois elevá-la a uma potência latexmath:[$k$] (onde latexmath:[$k$] é chamada de chave pública ou chave de encriptação), e extrair o latexmath:[$\mod n$], para, assim, chegar ao resultado. Como latexmath:[$m$], latexmath:[$n$], e latexmath:[$k$] são todos inteiros enormes, a eficiente computação de (latexmath:[$m^k \mod n$]) requer as ferramentas que desenvolvemos anteriormente. Detalhes em http://en.wikipedia.org/wiki/RSA_(algorithm) .

//_

.{zwsp}
====
Compute latexmath:[$2^{60} \mod 101$] usando exponenciação modular latexmath:[$(a^b) \mod c = ((a \mod c)^b) \mod c$] e divida e conquiste. Mostre todas as etapas.

{zwsp} +
*Solução:*

latexmath:[$2^{60} = (2^{30})^2 = ((2^{15})^2)^2 = ((2 \times 2^{14})^2)^2 = ((2 \times (2^7)^2)^2)^2 = ((2 \times(2 \times 2^6)^2)^2)^2 = ((2 \times (2 \times (2^3)^2)^2)^2)^2 = ((2 \times (2 \times (2 \times (2^2))^2)^2)^2)^2 = ((2 \times (2 \times (2 \times (2^2))^2)^2)^2)^2$]

Em outras palavras:

latexmath:[$2^{60} = (2^{30})^2$] +
latexmath:[$2^{30} = (2^{15})^2$] +
latexmath:[$2^{15} = 2 \times (2^7)^2$] +
latexmath:[$2^7 = 2 \times (2^3)^2$] +
latexmath:[$2^3 = 2 \times (2^1)^2$] +
latexmath:[$2^1 = 2$]

Usando aritmética latexmath:[$\mod 101$] e trabalhando bottom-up, temos:

latexmath:[$2^1 \mod 101 = 2 \mod 101 = 2$] +
latexmath:[$2^2 \mod 101 = 4 \mod 101 = 4$] +
latexmath:[$2^3 \mod 101 = 2 \times (2^1)^2 \mod 101 = 8 \mod 101 = 8$] +
latexmath:[$2^6 \mod 101 = \cdots = 64$] +
latexmath:[$2^7 \mod 101 = \cdots = 27$] +
latexmath:[$2^{14} \mod 101 = \cdots = 22$] +
latexmath:[$2^{15} \mod 101 = \cdots = 44$] +
latexmath:[$2^{30} \mod 101 = \cdots = 17$] +
latexmath:[$2^{60} \mod 101 = 172 \mod 101 = \cdots = 87$].
====

.{zwsp}
====
Qual é o último dígito de 1234567890123456789 elevado a 1025?

{zwsp} +
*Solução:* A palavra ``dígito'' significa que a aritmética é a da base 10. Para sabermos o último dígito, só precisamos operar na aritmética de módulo 10, e a fórmula é latexmath:[$(a^b) \mod c = ((a \mod c)^b) \mod c$]. Aqui, latexmath:[$a = 1234567890123456789$], latexmath:[$b = 1025$]; latexmath:[$c =10$]. Temos latexmath:[$a \mod c$] é 9. Começamos a operar com este valor, e sempre aplicamos latexmath:[$\mod 10$] a cada multiplicação. Usando divida e conquiste, temos:

latexmath:[$a^2 \mod 10 = ((a \mod 10)(a \mod 10)) \mod 10 = 81 \mod 10 = 1$] +
latexmath:[$a^4 \mod 10 = ((a^2 \mod 10)(a^2 \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$a^8 \mod 10 = ((a^4 \mod 10)(a^4 \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$a^{16} \mod 10 = ((a^8 \mod 10)(a^8 \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$\cdots$] +
latexmath:[$a^{1024} \mod 10 = ((a^{512} \mod 10)(a^{512} \mod 10)) \mod 10 = 1 \mod 10 = 1$] +
latexmath:[$a^{1025} \mod 10 = ((a^1 \mod 10)(a^{1024} \mod 10)) \mod 10 = (9 \times 1) \mod 10 = 9$]
====

==== Atividades

.Compute 270 mod 1001 usando exponenciação modular. Mostre todas as etapas.

[[sec-7-5]]
=== Congruências 

NOTE: Além dos livros texto, às vezes inspiramo-nos no bom sumário do livro _Programming Challenges (Skiena, Revilla)_ http://www.inf.ufrgs.br/~comba/inf1056-files/class01.pdf]

Sejam dois inteiros latexmath:[$b$],latexmath:[$c$], e seja um natural latexmath:[$m$] (chamado de modulus). Se latexmath:[$b \mod m = c \mod m$] (ou, equivalentemente, se latexmath:[$b-c$] é divisível por latexmath:[$m$]), então escreve-se latexmath:[$b \equiv c (\mod m)$], que é lido ``b,c são congruentes módulo m''. (Às vezes o modulus latexmath:[$m$] é entendido pelo contexto e pode ser omitido, ficando apenas implícito, de modo que se escreve apenas  latexmath:[$b \equiv c$], tendo-se o cuidado de não se confundir latexmath:[$\equiv$] com o sinal de equivalência.)

Congruências são (``apenas'') uma notação alternativa para a aritmética modular, mas, mesmo assim, a notação é importante, pois nos faz pensar sobre o conjunto de números inteiros latexmath:[$b$]\'s com um mesmo resto, latexmath:[$r$], quando divididos por latexmath:[$m$], e nos dá equações para representar o conjunto.

Podemos ver latexmath:[$b \equiv c (\mod m)$] como a classe de equivalência (o conjunto) onde qualquer elemento arbitrariamente escolhido, latexmath:[$x$], satisfaz latexmath:[$x \mod m = b \mod m$] (também igual a latexmath:[$c \mod m$]), e a diferença entre dois quaisquer elementos latexmath:[$x$],latexmath:[$y$] do conjunto é um múltiplo de latexmath:[$m$]. 

.{zwsp}
====
Que inteiros latexmath:[$x$] satisfazem a congruência latexmath:[$x \equiv 3 (\mod 9)$]?

{zwsp} +
*Solução:* latexmath:[$\{\ldots ,-33,-24,-15,-6,3,12,21,30,39,48, \ldots\} = 9k + 3$], em que latexmath:[$k$] é um número inteiro qualquer.
====

.{zwsp}
====
Que inteiros latexmath:[$x$] satisfazem (latexmath:[$2x \equiv 3 (\mod 9)$]) e (latexmath:[$2x \equiv 3 (\mod 4)$])?

{zwsp} +
*Solução:* latexmath:[$\{6,15,24,33,42, \ldots \} \cap \{\} = \{\}$]
====

==== Operações Sobre Congruências 

*Adição e Subtração:* + 
Suponha que latexmath:[$a \equiv b (\mod n)$] e latexmath:[$c \equiv d (\mod n)$]. Então, latexmath:[$(a + c) \equiv (b + d) (\mod n)$]. Também, latexmath:[$(a – c) \equiv (b - d) (\mod n)$]. +
Por exemplo, suponha que eu sei que latexmath:[$4x \equiv 7 (\mod 9)$] e latexmath:[$3x \equiv 3 (\mod 9)$]. Então, latexmath:[$(4x - 3x) \equiv (7-3) (\mod 9)$]. Portanto, latexmath:[$x \equiv 4 (\mod 9)$].

*Multiplicação:* +
É evidente que latexmath:[$a \equiv b (\mod n)$] implica que latexmath:[$(a \cdot d) \equiv (b \cdot d) (\mod n)$], adicionando a congruência reduzida para si mesma, latexmath:[$d$] vezes. Na verdade, a multiplicação geral também é válida, ou seja, (latexmath:[$a \equiv b (\mod n)$]) e (latexmath:[$c \equiv d (\mod n)$]) implicam latexmath:[$(a \cdot c) \equiv (b \cdot d) (\mod n)$].

*Divisão:* +
No entanto, não podemos impensadamente cancelar fatores comuns de congruências. Note-se que latexmath:[$(6 \times 2) \equiv (6 \times 1) (\mod 3)$], mas claramente é falso que latexmath:[$2 \equiv 1 (\mod 3)$]. + 
Para ver o que o problema é, note que podemos redefinir divisão como multiplicação por uma inversa, então latexmath:[$x/y$] é equivalente a latexmath:[$x(y^{-1})$]. Assim, podemos calcular latexmath:[$a/b (\mod n)$] se podemos encontrar um inverso latexmath:[$b^{-1}$] tal que latexmath:[$b(b^{-1}) \equiv 1 (\mod n)$]. Este inverso nem sempre existe – tente encontrar uma solução (inteira, claro) para latexmath:[$(2 \cdot x) \equiv 1 (\mod 4)$]. +
Sim, _podemos_ simplificar uma congruência latexmath:[$(a \cdot d) \equiv (b \cdot d) \mod (d \cdot n)$] para uma latexmath:[$a \equiv b (\mod n)$], de modo que podemos dividir todos os três termos por um fator comum, se houver. Assim, latexmath:[$170 \equiv 30 (\mod 140)$] implica que latexmath:[$17 \equiv 3 (\mod 14)$]. No entanto (, dado latexmath:[$(a \cdot d) \equiv (b \cdot d) \mod (n),), a congruência latexmath:[$a \equiv b (\mod n)$] deve ser falsa (ou seja, não tem solução) se latexmath:[$mdc(a,n)$] não divide latexmath:[$b$].

==== Resolvendo Congruências Lineares

Uma congruência linear é uma equação da forma latexmath:[$(a \cdot x) \equiv b (\mod n)$]. Resolver essa equação significa identificar quais os valores de latexmath:[$x$] que a satisfazem.

Nem todas essas equações têm soluções. Vimos números inteiros que não têm inversos multiplicativos em relação a um dado módulo, o que significa que latexmath:[$(a \cdot x) \equiv 1 (\mod n)$] não tem uma solução. Na verdade, latexmath:[$(a \cdot x) \equiv 1 (\mod n)$] tem uma solução se e somente se o módulo e o multiplicador são relativamente primos, ou seja, latexmath:[$mdc(a,n) = 1$]. Podemos utilizar o algoritmo de Euclides para encontrar esta inversa através da solução para latexmath:[$a' \cdot x + n \cdot y' = mdc(a,n) = 1$]. Assim, latexmath:[$((a \cdot x) \equiv 1 (\mod n)) \rightarrow ((a \cdot x) \equiv (a \cdot x' + n \cdot y') (\mod n))$].

Claramente latexmath:[$(n \cdot y') \equiv 0 (\mod n)$], então na verdade este inverso é simplesmente o latexmath:[$x'$] do algoritmo de Euclides.

Em geral, existem três casos, dependendo da relação entre latexmath:[$a$], latexmath:[$b$], e latexmath:[$n$]:

* latexmath:[$mdc(a,b,n) > 1$]. Então, podemos dividir todos os três termos por este divisor para obter uma congruência equivalente. Isso nos dá um única solução latexmath:[$\mod$] a nova base; ou; equivalentemente; latexmath:[$mdc(a,b,n)$] soluções (latexmath:[$\mod n$]).
* latexmath:[$mdc(a,n)$] não divide latexmath:[$b$]. Então, como descrito acima, a congruência pode não ter nenhuma solução.
* latexmath:[$mdc(a,n) = 1$]. Então há uma solução (latexmath:[$\mod n$]). Além disso, latexmath:[$x = (a^{-1}) \cdot b$] funciona, uma vez que latexmath:[$(aa^{-1}b) \equiv b (\mod n)$]. Como mostrado acima, este inverso existe e pode ser encontrado utilizando o algoritmo de Euclides.

.{zwsp}
====
Resolva o seguinte _sistema de congruências simultâneas_, onde os módulos são iguais: +
latexmath:[$4a + b \equiv 17 (\mod 26)$] +
latexmath:[$19a + b \equiv 3 (\mod 26)$] 

{zwsp} +
Solução:*

Resolva as equações normalmente - você vai acabar com

[latexmath]
++++
\[15a \equiv -14 \equiv 12(\mod 26)\]
++++

Para resolver latexmath:[$15a  \equiv  12 (\mod 26)$], você divide tudo por 3 e obtém latexmath:[$5a \equiv 4 (\mod 26)$]. Agora, use força bruta para achar um múltiplo de 5 que lhe dê 4 em módulo 26 (eu tenho certeza que há uma maneira mais elegante, mas fico satisfeito com a maneira que se segue). Este múltiplo é 6, veja: latexmath:[$5 \cdot 6 = 30  \equiv  4 \mod 26$]. Assim, latexmath:[$a \equiv 6$].

Aplicando isso na 1ª equação, latexmath:[$4a + b = 17$], você obtém latexmath:[$b = 17-24 = -7 = 19 \mod 26$].

Juntando tudo, as respostas são: latexmath:[$a \equiv 6 (\mod 26)$], e latexmath:[$b \equiv 19 (\mod 26)$].
====

O *Teorema Chinês do Resto* (que não vamos cobrar em exames) nos dá uma ferramenta para trabalhar com sistemas de congruências sobre módulos diferentes. Suponha que existe um inteiro latexmath:[$x$] tal que latexmath:[$x \equiv a_1 (\mod m_1)$] e latexmath:[$x \equiv a_2 (\mod m_2)$]. Então latexmath:[$x$] é unicamente determinado (latexmath:[$\mod m_1 m_2)$] se latexmath:[$m_1$] e latexmath:[$m_2$] são relativamente primos. Para encontrar esse latexmath:[$x$], e, assim, resolver o sistema de duas congruências, começamos por resolver as congruências lineares latexmath:[$m_2 b_1 \equiv 1 (\mod m_1)$] e latexmath:[$m_1 b_1 \equiv 1 (\mod m_2)$] para encontrar latexmath:[$b_1$] e latexmath:[$b_2$], respectivamente.
 
Em seguida, pode ser facilmente verificado que latexmath:[$x = a_1 b_1 m_2 + a_2 b_2 m_1$] é uma solução para ambas as congruências originais. 

Além disso, o teorema prontamente se estende aos sistemas de um número arbitrário de congruências cujos módulos são todos pares relativamente primos, analisados par a par.

Se latexmath:[$m_k$] é um inteiro positivo e latexmath:[$mdc(m_i,m_j) = 1 (i \not= j)$](números primos entre si) então o sistema de congruências lineares:

latexmath:[$x \equiv a_1 (\mod \cdot m_1)$] +
latexmath:[$x \equiv a_2 (\mod \cdot m_2)$] +
latexmath:[$x \equiv a_3 (\mod \cdot m_3)$] +
latexmath:[$x \equiv a_4 (\mod \cdot m_4)$] +
latexmath:[$x \equiv a_5 (\mod \cdot m_5)$] +
latexmath:[$x \equiv a_6 (\mod \cdot m_6)$] +
latexmath:[$\cdots$] +
latexmath:[$x \equiv a_{n-1} (\mod \cdot m_{n-1})$] +
latexmath:[$x \equiv a_n (\mod \cdot m_n)$] +
Tem uma única solução: latexmath:[$x \equiv X (\mod m) m = m_1 m_2 m_3 \cdot m_{n-1} m_n$] 

O valor de latexmath:[$X$] pode ser encontrado utilizando-se o Teorema Chinês do Resto: +
latexmath:[$X= a_1 \cdot M_1 \cdot x_1 + a_2 \cdot M_2 \cdot x_2+ a_3 \cdot M_3 \cdot x_3+ a_4 \cdot M_4 \cdot x_4 + \cdots + a_n \cdot M_n \cdot x_n$] +
latexmath:[$M_a$] é o produto de todos os latexmath:[$m_k$] com exceção de latexmath:[$m_a$] (Exemplo: latexmath:[$M_1=m_2 \cdot m_3 \cdot \cdots \cdot m_n$])
latexmath:[$x_a$] é o número que torna latexmath:[$M_a \cdot x_a \equiv 1(\mod m_a)$]

[[sec-7-5-3]]
==== Equações Diofantinas

*Equações Diofantinas* (no exame, no máximo, no máximo, poderá haver alguma pergunta conceitual do tipo ``que significa... qual a ideia básica..., etc.'') são fórmulas em que as variáveis são restritas a números inteiros.

Por exemplo, o último teorema de Fermat refere-se a respostas para a equação latexmath:[$a^n + b^n = c^n$]. Resolver tal equação para os números reais não é grande coisa. É somente se todas as variáveis forem restritas a números inteiros que o problema se torna difícil.
Equações diofantinas são difíceis de trabalhar, pois a divisão não é uma operação de rotina com fórmulas para inteiros. No entanto, existem algumas classes de equações diofantinas que são conhecidos como sendo solúveis e estas tendem a surgir frequentemente.

A classe mais importante é a de equações lineares diofantinas da forma latexmath:[$ax - ny = b$], em que latexmath:[$x$], latexmath:[$y$] são variáveis inteiras, e latexmath:[$a$], latexmath:[$b$], latexmath:[$n$] são constantes inteiras. 

Pode ser prontamente demonstrado que essas equações são equivalentes à solução da congruência latexmath:[$ax \equiv b (\mod n)$] e, consequentemente, podem ser resolvidas usando as técnicas da seção anterior. 

Análises diofantinas mais avançadas estão além do escopo deste pequeno livro de introdução à Matemática Discreta. Se você quiser ver mais sobre análises diofantinas, comece pelas referências- padrão na Teoria dos Números, tais como (Niven e Zuckerman 1991), (Hardy e Wright 1979), etc., depois siga para as referências adicionais que dão sobre tais análises. Depois, peça de um especialista referências mais novas e específicas.

==== Atividades

. Faça as tábuas de adição e multiplicação para latexmath:[$Z_6$]. (latexmath:[$Z_m$] é o conjunto das classes dos restos módulo latexmath:[$m$], isto é, latexmath:[$\{\bar{0},\bar{1}, \ldots ,\bar{m}\}$], onde \bar{y} é a classe latexmath:[$\{x \in \mathbb{Z} | x \equiv y (\mod m)\}$]).
. Encontre o resto da divisão de latexmath:[$7^{256}$] por 15.
. Estabeleça a validade do critério para decidir se um inteiro é divisível por 3 (três) que você aprendeu na quarta série do ensino fundamental.
. Mostre a validade da ``prova dos nove'' que foi ensinada na segunda série do ensino fundamental. 
. Considere a seguinte aﬁrmativa sobre um natural latexmath:[$n$]: ``Um natural é divisível por latexmath:[$n$] se-e-somente-se a soma de seus dígitos, quando representado na base 10, é divisível por latexmath:[$n$]''. Para que naturais latexmath:[$n$] esta aﬁrmativa é verdadeira?
. Liste todos os divisores de zero de latexmath:[$Z_{45}$].
. Encontre todos os valores inteiros de latexmath:[$X$] que satisfazem cada uma das congruências abaixo: +
[width="100%",cols="<,<,<",frame="none",grid="none"]
|====
|a) latexmath:[$5X \equiv 3 (\mod 9)$];
|b) latexmath:[$6X \equiv 3 (\mod 9)$];
|c) latexmath:[$6X \equiv 4 (\mod 9)$];
|d) latexmath:[$2X + 3 \equiv 5X = 9 (\mod 13)$];
|e) latexmath:[$X^2 \equiv 1 (\mod 16)$].
|
|====

=== Triplas Pitagóricas

*Triplas Pitagóricas* são três inteiros positivos latexmath:[$a,b,c$] tais que latexmath:[$a^2 + b^2 = c^2$].

Infinitas Triplas Pitagóricas podem ser obtidas a partir de uma, cada vez multiplicando-se esta por uma diferente constante positiva. Por isso, estamos interessados em Triplas Pitagóricas *Primitivas*, onde latexmath:[$a,b,c$] não têm fator comum (são primos entre si).

*Teorema das Triplas Pitagóricas:* Cada Tripla Pitagórica Primitiva latexmath:[$(a,b,c)$] (assume-se que latexmath:[$a$] é ímpar, latexmath:[$b$] é par, latexmath:[$a$] e latexmath:[$b$] são primos entre si) pode ser encontrada assim: +
latexmath:[$a = s \cdot t$], onde latexmath:[$s > t \geq 1$] são escolhidos como inteiros ímpares sem fatores comuns +
latexmath:[$b = \frac{(s^2 – t^2)}{2}$] (note que, assim, latexmath:[$b$] será par) +
latexmath:[$c = \frac{(s^2 + t^2)}{2}$]

NOTE: Ver prova na seção 2 de http://ssli.ee.washington.edu/~halloj3/math_sen_synth07.pdf. Mas o artigo em http://mathworld.wolfram.com/PythagoreanTriple.html é mais específico sobre o assunto.

.{zwsp}
====
Se você escolher latexmath:[$s = 3$]; latexmath:[$t = 1$]; achará a Tripla Pitagórica Primitiva que tem  latexmath:[$a = s \cdot t = 3 \cdot 1 = 3$]; latexmath:[$b = \frac{(9-1)}{2} = 4$]; latexmath:[$c = \frac{(9+1)}{2} = 5$].
====

.{zwsp}
====
Se você escolher latexmath:[$s = 9$]; latexmath:[$t = 7$]; achará a T.P. Primitiva que tem latexmath:[$a = s \cdot t = 9 \cdpt 7 = 63$]; latexmath:[$b = \frac{(s \cdot s – t \cdot t)}{2} = \frac{(81-49)}{2} = 16$]; latexmath:[$c = \frac{(s \cdot s + t \cdot t)}{2} = \frac{(81+49)}{2} = 65$].
====

.{zwsp}
====
Se você escolher latexmath:[$s = 5$]; latexmath:[$t = 3$]; achará a T.P. Primitiva que tem latexmath:[$a = s \cdot t = 15$]; latexmath:[$b = 8$]; latexmath:[$c = 17$].
====

.{zwsp}
====
latexmath:[$r = 2, s = 1, (a,b,c) = (3,4,5)$].

latexmath:[$r = 3, s = 2, (a,b,c) = (5,12,13)$].

latexmath:[$r = 4, s = 1, (a,b,c) = (15,8,17)$].

latexmath:[$r = 4, s = 3, (a,b,c) = (7,24,25)$].

latexmath:[$r = 5, s = 2, (a,b,c) = (21,20,29)$].

latexmath:[$r = 5, s = 4, (a,b,c) = (9,40,41)$].

latexmath:[$r = 99, s = 62, (a,b,c) = (5957,12276,13645$)].
====

[[Ex-5]]
.{zwsp}
====
Triplas Pitagóricas são formadas por 3 inteiros latexmath:[$(a,b,c)$] tais que latexmath:[$a^2 + b^2 = c^2$]. Estamos interessados somente nas Triplas Pitagóricas Primitivas, onde latexmath:[$a,b,c$] não têm nenhum divisor em comum (são primos entre si). Prove que ou latexmath:[$a$] ou latexmath:[$b$] é ímpar e o outro é o par, e que latexmath:[$c$] é sempre impar. 

{zwsp} +
*Solução:* 

* latexmath:[$a$] e latexmath:[$b$] não podem, simultaneamente, ser par: se o fossem, latexmath:[$c$] também seria par. Isto significa que latexmath:[$a, b, c$] e teriam um fator comum de 2, e assim latexmath:[$(a, b, c)$] não seria uma T.P. Primitiva. Portanto, latexmath:[$a$] e latexmath:[$b$] não podem, simultaneamente, ser par.
* latexmath:[$a$] e latexmath:[$b$] não podem, simultaneamente, ser ímpar: Se o fossem, então latexmath:[$c$] seria par. Isto significa que latexmath:[$a = 2x + 1$], latexmath:[$b = 2y + 1$], e latexmath:[$c = 2z$], para alguns números latexmath:[$x, y, \mbox{ e } z$]. Substitua latexmath:[$a = 2x + 1$],latexmath:[$ b = 2a + 1$], e latexmath:[$c = 2z$] na equação latexmath:[$a^2 + b^2 = c^2$] e simplifique até obter latexmath:[$2x^2 + 2x + 2y^2 + 2y + 1 = 2z^2$]. O lado esquerdo é ímpar e o lado direito é par (portanto a equação é falsa), de modo que latexmath:[$a$] e latexmath:[$b$] não podem ser simultaneamente ímpar.
* latexmath:[$c$] é ímpar: se um elemento do par latexmath:[$(a,b)$] é par e o outro é ímpar, então a soma de seus quadrados é ímpar.

Portanto, latexmath:[$c$] é ímpar.
====

.{zwsp}
====
Triplas Pitagóricas são formadas por 3 inteiros positivos latexmath:[$(a,b,c)$] tais que latexmath:[$a^2 + b^2 = c^2$]. Estamos interessados somente nas Triplas Pitagóricas Primitivas, onde latexmath:[$(a,b,c)$] não têm nenhum divisor em comum (são primos entre si). Prove que latexmath:[$a$] e latexmath:[$b$] não podem ambos ser par, nem podem ambos ser ímpar.

{zwsp} +
*Solução:*

Ora, este é o mesmo <<Ex-5>>, mas vamos conceder em resolvê-lo de novo, com palavras um pouquinho diferentes, talvez lhe ajude a compreender melhor algumas coisas de provas:

* latexmath:[$a$] e latexmath:[$b$] não podem ambos ser par, porque latexmath:[$a^2$] e latexmath:[$b^2$] seriam pares, portanto a soma deles (latexmath:[$c^2$]) teria que ser um par, portanto latexmath:[$a, b, c$] seriam divisíveis por 2 e a tripla não seria primitiva.
* latexmath:[$a$] e latexmath:[$b$] não podem ambos ser ímpar, porque, então, os seus quadrados deixariam resto 1 quando divididos por 4 (porque latexmath:[$(2n+1)^2 = 4n^2 + 2 \cdot 2n+1$]), então latexmath:[$a^2 + b^2$] deixaria resto 2 quando dividido por 4. Isto implicaria que latexmath:[$c$] é par, assim latexmath:[$c^2$] é divisível por 4. Esta é uma contradição: latexmath:[$c^2$] não pode deixar restos de ambos 0 e 2 quando dividido por 4. Assim não ambos de latexmath:[$a$] e latexmath:[$b$] são ímpar. 
====

[[Ex-Teo]]
.{zwsp}
====
Prove que, *em cada T.P. Primitiva, um dos números é divisível por 3, um dos números é divisível por 4, e um dos números é divisível por 5.*

{zwsp} +
*Solução:*

Reescrevamos o Teorema das Triplas Pitagóricas Primitivas: +
Se latexmath:[$(x,y,z)$] é uma T.P.Primitiva, então sejam os inteiros latexmath:[$a > b \geq 1$] escolhidos: 1) como primos entre si; 2) que não são, ambos, ímpares; 3) que satisfaçam: +
latexmath:[$x = 2ab$] +
latexmath:[$y = a^2 - b^2$] +
latexmath:[$z = a^2 + b^2$] 

1) Provemos que latexmath:[$x = 2ab$] é divisível por 4. +
latexmath:[$a$] e latexmath:[$b$] podem ser (ambos pares) XOR (um par e outro ímpar). (Se eles fossem ambos ímpares, isto contradizeria uma de nossas suposições originais.) Em qualquer caso, um deles tem que ser par. Digamos que o número par é o latexmath:[$a$]. Assim, latexmath:[$a = 2n$], para algum número inteiro latexmath:[$n$], e  latexmath:[$x = 2ab = 2 (2n)b = 4nb$] é divisível por 4. O mesmo vale se latexmath:[$b$] é par.

2) Provemos que um número (latexmath:[$x$] ou latexmath:[$y$] ou latexmath:[$c$]) é sempre divisível por 3. +
Qualquer inteiro latexmath:[$n$] pode ser escrito na forma:  latexmath:[$n \equiv p (\mod 3)$], onde latexmath:[$p$] é 0, 1 ou 2. +
Se latexmath:[$n \equiv 0 (\mod 3)$], então latexmath:[$n_2 \equiv 0 (\mod 3) \cdot 0 (\mod 3) \equiv 0 (\mod 3)$] +
Se latexmath:[$n \equiv 1 (\mod 3)$], então latexmath:[$n_2 \equiv 1 (\mod 3) \cdot 1 (\mod 3) \equiv 1 (\mod 3)$] +
Se latexmath:[$n \equiv 2 (\mod 3)$], então latexmath:[$n_2 \equiv 2 (\mod 3) \cdot 2 (\mod 3) \equiv 1 (\mod 3)$] +
Então, *todo inteiro elevado a 2 é 0 ou é 1, tudo isso (mod 3)*. +
Se algum de latexmath:[$x$], latexmath:[$y$] ou latexmath:[$z$] é igual a latexmath:[$0 (\mod 3)$], acabamos aprova, porque então eles serão divisíveis por 3. + 
Suponha que nenhum de latexmath:[$x$], latexmath:[$y$] ou latexmath:[$z$] é igual a latexmath:[$0 (\mod 3)$]. Sabemos que latexmath:[$x^2 + y^2 = z^2$] e, desde que latexmath:[$x$] e latexmath:[$y$] são iguais a latexmath:[$1 (\mod 3)$] ou latexmath:[$2 (\mod 3)$], latexmath:[$z^2 \equiv 1 (\mod 3) + 1 (\mod 3) \equiv 2 (\mod 3)$]. +
Mas isso contradiz com o que foi provado e sublinhado, pouco acima (``todo inteiro elevado a 2 é 0 ou é 1, tudo isso (latexmath:[$\mod 3$])''). +
Portanto, um dos três (latexmath:[$x$] ou latexmath:[$y$] ou latexmath:[$c$]) tem que ser divisível por 3.

3) Provemos que um número (latexmath:[$x$] ou latexmath:[$y$] ou latexmath:[$c$]) é um múltiplo de 5 +
Mais uma vez o mesmo tipo de argumento se mantém. Considere o que acontece quando elevamos inteiros ao quadrado, em latexmath:[$\mod 5$]. +
Digamos que latexmath:[$m = q (\mod 5)$]. Então: +
Se latexmath:[$q = 0$], então latexmath:[$m^2 = 0 (\mod 5)$] +
Se latexmath:[$q = 1$], então latexmath:[$m^2 = 1 (\mod 5)$] +
Se latexmath:[$q = 2$], então latexmath:[$m^2 = 4 (\mod 5)$] +
Se latexmath:[$q = 3$], então latexmath:[$m^2 = 4 (\mod 5)$] +
Se latexmath:[$q = 4$], então latexmath:[$m^2 = 1 (\mod 5)$] +
Assim, todo inteiro elevado a 2 é 0 ou é latexmath:[$1n$] ou é 4, tudo isso (latexmath:[$mod 5$]). +
Novamente, considere os nossos números latexmath:[$x$], latexmath:[$y$], e latexmath:[$z$]. +
Se algum deles é divisível por 5, então terminamos a prova. +
Suponha que nenhum deles é divisível por 5. A equação latexmath:[$x^2 + y^2 = z^2$] nos diz que latexmath:[$z^2$] é uma de três coisas: 0 (isto é, latexmath:[$1 +4$]), ou 2 (isto é, latexmath:[$1 +1$]), ou 3 (isto é, latexmath:[$4 + 4$]), tudo isso (latexmath:[$\mod 5$]). Uma vez que um número inteiro elevado ao quadrado nunca pode ser 2 ou 3 (latexmath:[$\mod 5$]), então latexmath:[$z^2$] deve ser latexmath:[$0 (\mod 5)$], o que significa que latexmath:[$z$] é divisível por 5. Isto contradiz a nossa suposição original. +
Por isso, um dos três números tem que ser divisível por 5.
====

.{zwsp}
====
À luz do teorema acima (<<Ex-Teo>>: ``um dos números é divisível por 3, outro dos números é divisível por 4, e um outro dos números é divisível por 5.''), como você explica que latexmath:[$a = 15$]; latexmath:[$b = 8$]; latexmath:[$c = 17$] formam uma T.P. (pois latexmath:[$a^2 + b^2 = 15^2 + 8^2 = 225+ 64= 289 = 17^2$] ), mas 17 não é divisível por 3, nem por 4, nem por 5?

{zwsp} +
*Solução:* A citação do teorema está errada. O correto somente diz ``um dos números é divisível por 3, um dos números é divisível por 4, e um dos números é divisível por 5.'' Não diz que esses números são distintos. 15 é divisível por 3, 8 é divisível por 4, e 15 é divisível por 5.
====

=== Recapitulando

Parabéns! Você concluiu o capítulo 7 e, se foi disciplinado e realmente ``suou'' estudando 4 a 8 h cada semana, deve ter aprendido muitas coisas da parte básica da ``Teoria dos Números'' que lhe serão indispensáveis ou muito úteis em todo o resto do curso e sua vida profissional: Conceitos e propriedades dos primos, como testar a primalidade de um natural exatamente (se for pequeno) e com altíssima probabilidade e eficiência (se for enorme); divisibilidade e como achar latexmath:[$mdc$] e latexmath:[$mmc$] eficientemente; aritmética modular e sua aplicação à rápida exponenciação modular, vital para muita coisa da criptografia; congruências; triplas pitagóricas; as mais simples equações diofantinas e seus sistemas de equações. 

Agora, um esforço final: invista pesado na próxima semana, revisando todas as 7 unidades, particularmente todos os exercícios que você já fez para nota e todos os exercícios de auto-avaliação (sem nota) preparatórios para o exame final, depois confiantemente se submeta à prova final. Você pode ter pleno sucesso, só depende de você fazer este esforço final. 

Desejamos-lhe todo sucesso nas provas finais desta disciplina, e na continuação do curso, e em toda sua vida profissional!

////
Sempre termine os arquivos com uma linha em branco.
////